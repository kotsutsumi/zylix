# アニメーションシステム設計書 (v0.13.0)

> **ステータス**: 計画中
> **予定リリース**: 2027年Q1
> **前提条件**: v0.12.0 完了

---

## 1. 概要

### 1.1 目的

Lottieベクターアニメーションと Live2D キャラクターアニメーションをクロスプラットフォームで提供する統合アニメーションシステムを実装する。

### 1.2 サポート範囲

| 機能 | iOS | Android | Web | macOS | Windows | Linux |
|------|-----|---------|-----|-------|---------|-------|
| Lottie | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| Live2D | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| CSS Animation | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| Spring Animation | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |

---

## 2. アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                   Animation Controller                      │
│  (統一アニメーションAPI、タイムライン管理、イベント)         │
├─────────────────────────────────────────────────────────────┤
│      Lottie Engine      │      Live2D Engine               │
│  (JSON解析、レンダリング) │  (モデル管理、物理演算)          │
├─────────────────────────────────────────────────────────────┤
│                    Rendering Backend                        │
├──────────┬──────────┬──────────┬──────────┬────────────────┤
│  iOS     │ Android  │   Web    │  macOS   │ Windows/Linux  │
│ CoreAnim │ Canvas   │ Canvas/  │ CoreAnim │ Skia/Cairo     │
│ Metal    │ OpenGL   │ WebGL    │ Metal    │ OpenGL         │
└──────────┴──────────┴──────────┴──────────┴────────────────┘
```

---

## 3. Lottie アニメーション

### 3.1 コアAPI設計

```zig
// core/src/animation/lottie/engine.zig

/// Lottieアニメーションエンジン
pub const LottieAnimation = struct {
    data: *LottieData,
    renderer: *Renderer,

    // アニメーション状態
    current_frame: f32 = 0,
    playback_speed: f32 = 1.0,
    is_playing: bool = false,
    loop_mode: LoopMode = .loop,

    // メタデータ
    duration_frames: f32,
    frame_rate: f32,
    width: u32,
    height: u32,

    const Self = @This();

    /// JSONファイルからロード
    pub fn load(json_data: []const u8) !Self {
        const data = try LottieParser.parse(json_data);
        const renderer = try Renderer.init(data);

        return Self{
            .data = data,
            .renderer = renderer,
            .duration_frames = data.op - data.ip,
            .frame_rate = data.fr,
            .width = @intFromFloat(data.w),
            .height = @intFromFloat(data.h),
        };
    }

    /// 再生開始
    pub fn play(self: *Self) void {
        self.is_playing = true;
    }

    /// 一時停止
    pub fn pause(self: *Self) void {
        self.is_playing = false;
    }

    /// 停止 (先頭に戻る)
    pub fn stop(self: *Self) void {
        self.is_playing = false;
        self.current_frame = 0;
    }

    /// 特定フレームにシーク
    pub fn seekToFrame(self: *Self, frame: f32) void {
        self.current_frame = @mod(frame, self.duration_frames);
    }

    /// 進捗率 (0.0 - 1.0) でシーク
    pub fn seekToProgress(self: *Self, progress: f32) void {
        self.current_frame = progress * self.duration_frames;
    }

    /// フレーム更新 (毎フレーム呼び出し)
    pub fn update(self: *Self, delta_time: f32) void {
        if (!self.is_playing) return;

        const frame_delta = delta_time * self.frame_rate * self.playback_speed;
        self.current_frame += frame_delta;

        if (self.current_frame >= self.duration_frames) {
            switch (self.loop_mode) {
                .none => {
                    self.current_frame = self.duration_frames;
                    self.is_playing = false;
                    if (self.on_complete) |cb| cb();
                },
                .loop => {
                    self.current_frame = @mod(self.current_frame, self.duration_frames);
                },
                .ping_pong => {
                    self.playback_speed *= -1;
                },
            }
        }
    }

    /// 現在のフレームをレンダリング
    pub fn render(self: *Self, surface: *Surface) void {
        self.renderer.render(self.data, self.current_frame, surface);
    }

    // イベントコールバック
    on_complete: ?*const fn () void = null,
    on_loop: ?*const fn () void = null,
    on_frame: ?*const fn (frame: f32) void = null,
};

pub const LoopMode = enum {
    none,       // 1回再生
    loop,       // 無限ループ
    ping_pong,  // 往復
};
```

### 3.2 Lottie JSON パーサー

```zig
// core/src/animation/lottie/parser.zig

pub const LottieData = struct {
    v: []const u8,           // バージョン
    fr: f32,                 // フレームレート
    ip: f32,                 // 開始フレーム
    op: f32,                 // 終了フレーム
    w: f32,                  // 幅
    h: f32,                  // 高さ
    nm: []const u8,          // 名前
    ddd: bool,               // 3D
    assets: []Asset,         // アセット
    layers: []Layer,         // レイヤー
    markers: []Marker,       // マーカー
};

pub const Layer = struct {
    ty: LayerType,
    nm: []const u8,
    ind: u32,
    parent: ?u32,
    ip: f32,
    op: f32,
    st: f32,
    ks: Transform,
    shapes: ?[]Shape = null,  // シェイプレイヤー用
};

pub const LayerType = enum(u8) {
    precomp = 0,
    solid = 1,
    image = 2,
    null_ = 3,
    shape = 4,
    text = 5,
};

pub const Shape = union(enum) {
    group: ShapeGroup,
    rect: RectShape,
    ellipse: EllipseShape,
    path: PathShape,
    fill: FillShape,
    stroke: StrokeShape,
    transform: TransformShape,
};

pub const LottieParser = struct {
    pub fn parse(json: []const u8) !*LottieData {
        var parser = std.json.Parser.init(allocator, false);
        defer parser.deinit();

        const tree = try parser.parse(json);
        return parseRoot(tree.root);
    }

    fn parseRoot(root: std.json.Value) !*LottieData {
        // JSON を LottieData 構造体に変換
        // ...
    }
};
```

### 3.3 TypeScript API

```typescript
// bindings/typescript/src/animation/lottie.ts

export interface LottieConfig {
  src: string | object;  // URL or JSON object
  autoplay?: boolean;
  loop?: boolean | number;
  speed?: number;
  renderer?: 'svg' | 'canvas' | 'html';
}

export class LottiePlayer {
  private handle: number;
  private _isPlaying: boolean = false;

  static async load(config: LottieConfig): Promise<LottiePlayer> {
    const data = typeof config.src === 'string'
      ? await fetch(config.src).then(r => r.json())
      : config.src;

    const handle = await native.loadLottie(data, config);
    const player = new LottiePlayer(handle);

    if (config.autoplay) {
      player.play();
    }

    return player;
  }

  // 基本制御
  play(): void { this._isPlaying = true; native.lottiePlay(this.handle); }
  pause(): void { this._isPlaying = false; native.lottiePause(this.handle); }
  stop(): void { this._isPlaying = false; native.lottieStop(this.handle); }

  // シーク
  goToFrame(frame: number): void { native.lottieSeekFrame(this.handle, frame); }
  goToProgress(progress: number): void { native.lottieSeekProgress(this.handle, progress); }

  // プロパティ
  get isPlaying(): boolean { return this._isPlaying; }
  get currentFrame(): number { return native.lottieGetFrame(this.handle); }
  get totalFrames(): number { return native.lottieGetTotalFrames(this.handle); }
  get duration(): number { return native.lottieGetDuration(this.handle); }

  // 速度制御
  setSpeed(speed: number): void { native.lottieSetSpeed(this.handle, speed); }
  setDirection(direction: 1 | -1): void { native.lottieSetDirection(this.handle, direction); }

  // ループ
  setLooping(loop: boolean): void { native.lottieSetLoop(this.handle, loop); }

  // セグメント再生
  playSegments(segments: [number, number][], forceFlag?: boolean): void {
    native.lottiePlaySegments(this.handle, segments, forceFlag ?? false);
  }

  // マーカー
  goToMarker(name: string): void { native.lottieGoToMarker(this.handle, name); }
  playMarkers(from: string, to: string): void {
    native.lottiePlayMarkers(this.handle, from, to);
  }

  // イベント
  on(event: 'complete' | 'loopComplete' | 'enterFrame', callback: () => void): void {
    native.lottieOn(this.handle, event, callback);
  }

  // 要素にアタッチ
  attachTo(element: HTMLElement): void {
    native.lottieAttach(this.handle, element);
  }

  destroy(): void {
    native.lottieDestroy(this.handle);
  }
}
```

### 3.4 React コンポーネント

```tsx
// bindings/typescript/src/animation/LottieView.tsx

export interface LottieViewProps {
  source: string | object;
  autoPlay?: boolean;
  loop?: boolean;
  speed?: number;
  style?: CSSProperties;
  onAnimationFinish?: () => void;
  onAnimationLoop?: () => void;
}

export function LottieView({
  source,
  autoPlay = true,
  loop = true,
  speed = 1,
  style,
  onAnimationFinish,
  onAnimationLoop,
}: LottieViewProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const playerRef = useRef<LottiePlayer | null>(null);

  useEffect(() => {
    if (!containerRef.current) return;

    LottiePlayer.load({
      src: source,
      autoplay: autoPlay,
      loop,
      speed,
    }).then(player => {
      playerRef.current = player;
      player.attachTo(containerRef.current!);

      if (onAnimationFinish) {
        player.on('complete', onAnimationFinish);
      }
      if (onAnimationLoop) {
        player.on('loopComplete', onAnimationLoop);
      }
    });

    return () => {
      playerRef.current?.destroy();
    };
  }, [source]);

  useEffect(() => {
    playerRef.current?.setSpeed(speed);
  }, [speed]);

  useEffect(() => {
    playerRef.current?.setLooping(loop);
  }, [loop]);

  return <div ref={containerRef} style={style} />;
}
```

---

## 4. Live2D 統合

### 4.1 Cubism SDK 統合

```zig
// core/src/animation/live2d/cubism.zig

const cubism = @cImport({
    @cInclude("Live2DCubismCore.h");
});

/// Live2D モデル
pub const Live2DModel = struct {
    moc: *cubism.csmMoc,
    model: *cubism.csmModel,
    physics: ?*Physics,
    expressions: std.StringHashMap(*Expression),
    motions: std.StringHashMap(*Motion),

    // パラメータ
    param_angle_x: u32,
    param_angle_y: u32,
    param_angle_z: u32,
    param_eye_l_open: u32,
    param_eye_r_open: u32,
    param_mouth_open: u32,

    const Self = @This();

    /// モデルをロード
    pub fn load(moc_path: []const u8) !Self {
        const moc_data = try std.fs.cwd().readFileAlloc(allocator, moc_path, 10 * 1024 * 1024);
        defer allocator.free(moc_data);

        const moc = cubism.csmReviveMocInPlace(moc_data.ptr, @intCast(moc_data.len));
        if (moc == null) return error.InvalidMoc;

        const model_size = cubism.csmGetSizeofModel(moc);
        const model_memory = try allocator.alignedAlloc(u8, 16, model_size);
        const model = cubism.csmInitializeModelInPlace(moc, model_memory.ptr, model_size);

        var self = Self{
            .moc = moc,
            .model = model,
            .physics = null,
            .expressions = std.StringHashMap(*Expression).init(allocator),
            .motions = std.StringHashMap(*Motion).init(allocator),
            .param_angle_x = 0,
            .param_angle_y = 0,
            .param_angle_z = 0,
            .param_eye_l_open = 0,
            .param_eye_r_open = 0,
            .param_mouth_open = 0,
        };

        self.findParameters();
        return self;
    }

    /// パラメータを設定
    pub fn setParameter(self: *Self, id: u32, value: f32) void {
        const params = cubism.csmGetParameterValues(self.model);
        params[id] = value;
    }

    /// 顔の向きを設定
    pub fn setFaceAngle(self: *Self, x: f32, y: f32, z: f32) void {
        self.setParameter(self.param_angle_x, x);
        self.setParameter(self.param_angle_y, y);
        self.setParameter(self.param_angle_z, z);
    }

    /// 目の開き具合を設定
    pub fn setEyeOpen(self: *Self, left: f32, right: f32) void {
        self.setParameter(self.param_eye_l_open, left);
        self.setParameter(self.param_eye_r_open, right);
    }

    /// 口の開き具合を設定 (リップシンク用)
    pub fn setMouthOpen(self: *Self, value: f32) void {
        self.setParameter(self.param_mouth_open, value);
    }

    /// 表情を再生
    pub fn setExpression(self: *Self, name: []const u8) void {
        if (self.expressions.get(name)) |expr| {
            expr.apply(self);
        }
    }

    /// モーションを再生
    pub fn playMotion(self: *Self, name: []const u8, options: MotionOptions) void {
        if (self.motions.get(name)) |motion| {
            motion.play(options);
        }
    }

    /// 更新 (毎フレーム)
    pub fn update(self: *Self, delta_time: f32) void {
        // 物理演算
        if (self.physics) |physics| {
            physics.update(self, delta_time);
        }

        // モーション更新
        for (self.motions.values()) |motion| {
            if (motion.is_playing) {
                motion.update(delta_time);
                motion.apply(self);
            }
        }

        // モデル更新
        cubism.csmUpdateModel(self.model);
    }

    /// レンダリング
    pub fn render(self: *Self, renderer: *Renderer) void {
        const drawable_count = cubism.csmGetDrawableCount(self.model);
        const render_orders = cubism.csmGetDrawableRenderOrders(self.model);

        // 描画順でソート
        var sorted_indices = try allocator.alloc(u32, drawable_count);
        defer allocator.free(sorted_indices);

        for (0..drawable_count) |i| {
            sorted_indices[render_orders[i]] = @intCast(i);
        }

        // 各ドローアブルをレンダリング
        for (sorted_indices) |index| {
            const vertices = cubism.csmGetDrawableVertexPositions(self.model)[index];
            const uvs = cubism.csmGetDrawableVertexUvs(self.model)[index];
            const indices = cubism.csmGetDrawableIndices(self.model)[index];
            const texture_index = cubism.csmGetDrawableTextureIndices(self.model)[index];

            renderer.drawMesh(vertices, uvs, indices, self.textures[texture_index]);
        }
    }
};
```

### 4.2 TypeScript API

```typescript
// bindings/typescript/src/animation/live2d.ts

export interface Live2DConfig {
  modelPath: string;      // .model3.json のパス
  scale?: number;
  position?: { x: number; y: number };
  autoBreath?: boolean;   // 自動呼吸
  autoEyeBlink?: boolean; // 自動まばたき
}

export class Live2DModel {
  private handle: number;

  static async load(config: Live2DConfig): Promise<Live2DModel> {
    const handle = await native.loadLive2D(config);
    return new Live2DModel(handle);
  }

  // パラメータ制御
  setParameter(name: string, value: number): void {
    native.live2dSetParam(this.handle, name, value);
  }

  getParameter(name: string): number {
    return native.live2dGetParam(this.handle, name);
  }

  // 顔の向き (視線追従)
  setLookAt(x: number, y: number): void {
    native.live2dSetLookAt(this.handle, x, y);
  }

  // 表情
  setExpression(name: string): void {
    native.live2dSetExpression(this.handle, name);
  }

  // モーション
  playMotion(group: string, index: number, priority?: number): void {
    native.live2dPlayMotion(this.handle, group, index, priority ?? 1);
  }

  stopMotion(): void {
    native.live2dStopMotion(this.handle);
  }

  // リップシンク
  setLipSync(value: number): void {
    native.live2dSetLipSync(this.handle, value);
  }

  // 音声からリップシンク
  async lipSyncFromAudio(audioSource: AudioSource): Promise<void> {
    const analyzer = new AudioAnalyzer(audioSource);
    analyzer.onAmplitude = (amp) => {
      this.setLipSync(amp);
    };
    await analyzer.start();
  }

  // 要素にアタッチ
  attachTo(canvas: HTMLCanvasElement): void {
    native.live2dAttach(this.handle, canvas);
  }

  // イベント
  on(event: 'motionStart' | 'motionEnd' | 'hit', callback: (...args: any[]) => void): void {
    native.live2dOn(this.handle, event, callback);
  }

  // 当たり判定
  hitTest(x: number, y: number): string | null {
    return native.live2dHitTest(this.handle, x, y);
  }

  destroy(): void {
    native.live2dDestroy(this.handle);
  }
}
```

### 4.3 使用例: インタラクティブキャラクター

```typescript
import { Live2DModel } from '@zylix/animation';

async function createCharacter() {
  const canvas = document.getElementById('live2d-canvas') as HTMLCanvasElement;

  const model = await Live2DModel.load({
    modelPath: 'assets/character/model.model3.json',
    scale: 1.5,
    autoBreath: true,
    autoEyeBlink: true,
  });

  model.attachTo(canvas);

  // マウス追従
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const y = ((e.clientY - rect.top) / rect.height) * 2 - 1;
    model.setLookAt(x, -y);
  });

  // クリックで反応
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    const y = (e.clientY - rect.top) / rect.height;

    const hitArea = model.hitTest(x, y);

    if (hitArea === 'Head') {
      model.playMotion('Tap', 0);
      model.setExpression('happy');
    } else if (hitArea === 'Body') {
      model.playMotion('Tap', 1);
    }
  });

  // 音声リップシンク
  const audio = new Audio('assets/voice.mp3');
  audio.onplay = () => model.lipSyncFromAudio(audio);
  audio.play();
}
```

---

## 5. Spring アニメーション

### 5.1 物理ベースアニメーション

```zig
// core/src/animation/spring.zig

/// スプリングアニメーション
pub const SpringAnimation = struct {
    // バネ定数
    stiffness: f32 = 100,   // 硬さ
    damping: f32 = 10,      // 減衰
    mass: f32 = 1,          // 質量

    // 状態
    position: f32,
    velocity: f32,
    target: f32,

    const Self = @This();

    pub fn init(initial: f32) Self {
        return Self{
            .position = initial,
            .velocity = 0,
            .target = initial,
        };
    }

    pub fn setTarget(self: *Self, target: f32) void {
        self.target = target;
    }

    /// 更新 (Verlet 積分)
    pub fn update(self: *Self, dt: f32) f32 {
        const displacement = self.position - self.target;

        // F = -kx - bv (フックの法則 + 減衰)
        const spring_force = -self.stiffness * displacement;
        const damping_force = -self.damping * self.velocity;
        const acceleration = (spring_force + damping_force) / self.mass;

        self.velocity += acceleration * dt;
        self.position += self.velocity * dt;

        return self.position;
    }

    /// 静止したかどうか
    pub fn isAtRest(self: *Self) bool {
        const threshold = 0.001;
        return @abs(self.position - self.target) < threshold and
               @abs(self.velocity) < threshold;
    }
};
```

### 5.2 TypeScript API

```typescript
// bindings/typescript/src/animation/spring.ts

export interface SpringConfig {
  stiffness?: number;
  damping?: number;
  mass?: number;
}

export function useSpring(
  initial: number,
  config?: SpringConfig
): [number, (target: number) => void] {
  const [value, setValue] = useState(initial);
  const springRef = useRef(new SpringAnimation(initial, config));

  const setTarget = useCallback((target: number) => {
    springRef.current.setTarget(target);

    const animate = () => {
      const newValue = springRef.current.update(1/60);
      setValue(newValue);

      if (!springRef.current.isAtRest()) {
        requestAnimationFrame(animate);
      }
    };

    requestAnimationFrame(animate);
  }, []);

  return [value, setTarget];
}

// 使用例
function AnimatedBox() {
  const [x, setX] = useSpring(0, { stiffness: 150, damping: 15 });

  return (
    <div
      style={{ transform: `translateX(${x}px)` }}
      onClick={() => setX(x === 0 ? 200 : 0)}
    >
      Click me
    </div>
  );
}
```

---

## 6. タイムライン管理

```typescript
// bindings/typescript/src/animation/timeline.ts

export class Timeline {
  private animations: TimelineEntry[] = [];
  private currentTime: number = 0;
  private isPlaying: boolean = false;

  // アニメーション追加
  add(
    target: any,
    properties: Record<string, number>,
    options: TimelineOptions
  ): this {
    this.animations.push({
      target,
      properties,
      startTime: options.at ?? this.getDuration(),
      duration: options.duration ?? 1000,
      easing: options.easing ?? 'easeInOut',
    });
    return this;
  }

  // 同時実行
  addParallel(entries: TimelineEntry[]): this {
    const startTime = this.getDuration();
    for (const entry of entries) {
      this.animations.push({ ...entry, startTime });
    }
    return this;
  }

  // 再生
  play(): Promise<void> {
    return new Promise((resolve) => {
      this.isPlaying = true;
      const startTime = performance.now();

      const tick = () => {
        if (!this.isPlaying) return;

        this.currentTime = performance.now() - startTime;
        this.updateAnimations();

        if (this.currentTime < this.getDuration()) {
          requestAnimationFrame(tick);
        } else {
          this.isPlaying = false;
          resolve();
        }
      };

      requestAnimationFrame(tick);
    });
  }

  pause(): void { this.isPlaying = false; }
  resume(): void { this.isPlaying = true; }
  seek(time: number): void { this.currentTime = time; this.updateAnimations(); }

  private updateAnimations(): void {
    for (const anim of this.animations) {
      if (this.currentTime < anim.startTime) continue;
      if (this.currentTime > anim.startTime + anim.duration) continue;

      const progress = (this.currentTime - anim.startTime) / anim.duration;
      const easedProgress = this.ease(progress, anim.easing);

      for (const [prop, endValue] of Object.entries(anim.properties)) {
        const startValue = anim.startValues?.[prop] ?? 0;
        anim.target[prop] = startValue + (endValue - startValue) * easedProgress;
      }
    }
  }

  private getDuration(): number {
    return Math.max(0, ...this.animations.map(a => a.startTime + a.duration));
  }
}
```

---

## 7. 実装スケジュール

| タスク | 期間 |
|--------|------|
| Lottie JSON パーサー | 2週間 |
| Lottie レンダラー (Canvas/WebGL) | 3週間 |
| Lottie プラットフォーム最適化 | 2週間 |
| Live2D Cubism SDK 統合 | 3週間 |
| Live2D 物理演算 | 2週間 |
| Live2D モーション/表情 | 2週間 |
| Spring アニメーション | 1週間 |
| タイムライン管理 | 1週間 |
| テスト & ドキュメント | 2週間 |

---

## 8. 依存関係

| ライブラリ | バージョン | 用途 |
|-----------|-----------|------|
| Live2D Cubism SDK Native | 5-r.4.1 | Live2Dレンダリング |
| lottie-web | 参考実装 | Lottie JSON仕様 |
| rlottie | 参考実装 | C++ Lottieレンダラー |
