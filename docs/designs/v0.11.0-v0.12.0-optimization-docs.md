# パフォーマンス最適化 & ドキュメント設計書 (v0.11.0 - v0.12.0)

> **ステータス**: 計画中
> **予定リリース**: 2026年Q3-Q4
> **前提条件**: v0.10.0 完了

---

## Part 1: パフォーマンス最適化 (v0.11.0)

### 1. 概要

フレームワーク全体のパフォーマンスを最適化し、本番環境で使用可能なレベルの品質を達成する。

### 2. 最適化ターゲット

| メトリクス | 現状 (推定) | 目標 | 改善率 |
|-----------|------------|------|--------|
| WASMバンドルサイズ (gzip) | ~300KB | <100KB | 66% |
| 初回レンダリング時間 | ~200ms | <50ms | 75% |
| 1000コンポーネント再レンダリング | ~32ms | <16ms | 50% |
| メモリ使用量 (1000コンポーネント) | ~50MB | <30MB | 40% |
| TTI (Time to Interactive) | ~1.5s | <1s | 33% |

---

### 3. Virtual DOM最適化

#### 3.1 差分アルゴリズム改善

```zig
// core/src/vdom/diff_v2.zig

/// 最適化された差分アルゴリズム
/// - キー付き子要素の O(n) マッチング
/// - 静的サブツリーのスキップ
/// - メモ化による重複計算回避
pub const OptimizedDiffer = struct {
    // 静的解析結果のキャッシュ
    static_subtrees: std.AutoHashMap(NodeId, void),

    // 前回の差分結果キャッシュ
    patch_cache: std.AutoHashMap(CacheKey, []Patch),

    pub fn diff(self: *Self, old: *VNode, new: *VNode) []Patch {
        // 静的サブツリーをスキップ
        if (self.isStaticSubtree(new)) {
            if (self.areEqual(old, new)) return &.{};
        }

        // キャッシュ確認
        const cache_key = CacheKey{ .old_id = old.id, .new_id = new.id };
        if (self.patch_cache.get(cache_key)) |cached| {
            return cached;
        }

        // 実際の差分計算
        const patches = self.computeDiff(old, new);
        self.patch_cache.put(cache_key, patches);
        return patches;
    }

    /// キー付き子要素の最長共通部分列 (LCS) ベースマッチング
    fn diffKeyedChildren(self: *Self, old_children: []VNode, new_children: []VNode) []Patch {
        // Hunt-Szymanski アルゴリズム (O(n log n))
        const lcs = self.findLCS(old_children, new_children);

        var patches = std.ArrayList(Patch).init(allocator);

        // 削除されたノード
        for (old_children) |old| {
            if (!lcs.contains(old.key)) {
                patches.append(.{ .remove = old.id });
            }
        }

        // 追加・移動されたノード
        for (new_children, 0..) |new, i| {
            if (!lcs.contains(new.key)) {
                patches.append(.{ .insert = .{ .node = new, .index = i } });
            } else if (self.needsMove(old_children, new, i)) {
                patches.append(.{ .move = .{ .id = new.id, .to_index = i } });
            }
        }

        return patches.toOwnedSlice();
    }
};
```

#### 3.2 静的解析とコンパイル時最適化

```zig
// core/src/compiler/static_analyzer.zig

/// コンパイル時に静的サブツリーを特定
pub const StaticAnalyzer = struct {
    /// ノードが静的かどうかを判定
    /// - props が定数
    /// - イベントハンドラなし
    /// - 子ノードがすべて静的
    pub fn isStatic(node: *VNode) bool {
        // 動的バインディングチェック
        if (node.hasDynamicProps()) return false;
        if (node.hasEventHandlers()) return false;

        // 子ノードを再帰チェック
        for (node.children) |child| {
            if (!isStatic(child)) return false;
        }

        return true;
    }

    /// 静的ノードを事前レンダリング
    pub fn hoistStatic(tree: *VNode) *VNode {
        if (isStatic(tree)) {
            // 静的ノードをスナップショットに変換
            return StaticNode.fromVNode(tree);
        }

        // 子ノードを再帰処理
        for (tree.children, 0..) |child, i| {
            tree.children[i] = hoistStatic(child);
        }

        return tree;
    }
};
```

---

### 4. バンドルサイズ削減

#### 4.1 Tree Shaking

```zig
// core/src/compiler/tree_shaker.zig

/// 未使用コードの削除
pub const TreeShaker = struct {
    used_symbols: std.StringHashMap(void),
    dead_code: std.ArrayList([]const u8),

    pub fn analyze(self: *Self, entry_point: []const u8) void {
        // エントリーポイントから到達可能なシンボルを収集
        self.collectReachable(entry_point);
    }

    pub fn shake(self: *Self, modules: []Module) []Module {
        var result = std.ArrayList(Module).init(allocator);

        for (modules) |module| {
            var shaken_exports = std.ArrayList(Export).init(allocator);

            for (module.exports) |export| {
                if (self.used_symbols.contains(export.name)) {
                    shaken_exports.append(export);
                } else {
                    self.dead_code.append(export.name);
                }
            }

            if (shaken_exports.items.len > 0) {
                result.append(.{
                    .name = module.name,
                    .exports = shaken_exports.toOwnedSlice(),
                });
            }
        }

        return result.toOwnedSlice();
    }
};
```

#### 4.2 コード分割

```typescript
// bindings/typescript/src/lazy.ts

// 動的インポートによる遅延ロード
export function lazy<T extends ComponentType>(
  importFn: () => Promise<{ default: T }>
): LazyComponent<T> {
  let Component: T | null = null;
  let promise: Promise<T> | null = null;

  return {
    // Suspense と連携
    read(): T {
      if (Component) return Component;

      if (!promise) {
        promise = importFn().then(mod => {
          Component = mod.default;
          return Component;
        });
      }

      throw promise;
    },

    // プリロード
    preload(): Promise<T> {
      if (Component) return Promise.resolve(Component);
      return importFn().then(mod => {
        Component = mod.default;
        return Component;
      });
    },
  };
}

// 使用例
const HeavyComponent = lazy(() => import('./HeavyComponent'));

// ルートベースの分割
const routes = {
  '/dashboard': lazy(() => import('./pages/Dashboard')),
  '/settings': lazy(() => import('./pages/Settings')),
  '/profile': lazy(() => import('./pages/Profile')),
};
```

---

### 5. メモリ最適化

#### 5.1 オブジェクトプール

```zig
// core/src/memory/pool.zig

/// 再利用可能なオブジェクトプール
pub fn ObjectPool(comptime T: type) type {
    return struct {
        free_list: std.ArrayList(*T),
        allocator: std.mem.Allocator,
        initial_capacity: usize,

        const Self = @This();

        pub fn init(allocator: std.mem.Allocator, capacity: usize) Self {
            var pool = Self{
                .free_list = std.ArrayList(*T).init(allocator),
                .allocator = allocator,
                .initial_capacity = capacity,
            };

            // 事前割り当て
            pool.preallocate(capacity);
            return pool;
        }

        pub fn acquire(self: *Self) *T {
            if (self.free_list.popOrNull()) |obj| {
                return obj;
            }
            return self.allocator.create(T) catch @panic("OOM");
        }

        pub fn release(self: *Self, obj: *T) void {
            // オブジェクトをリセット
            obj.* = std.mem.zeroes(T);
            self.free_list.append(obj) catch {};
        }

        fn preallocate(self: *Self, count: usize) void {
            for (0..count) |_| {
                const obj = self.allocator.create(T) catch continue;
                self.free_list.append(obj) catch {};
            }
        }
    };
}

// VNodeプール
pub var vnode_pool = ObjectPool(VNode).init(std.heap.page_allocator, 1000);
```

#### 5.2 アリーナアロケーター

```zig
// core/src/memory/arena.zig

/// フレーム単位のアリーナアロケーター
pub const FrameArena = struct {
    arena: std.heap.ArenaAllocator,
    frame_count: u64 = 0,

    pub fn init(backing: std.mem.Allocator) FrameArena {
        return .{
            .arena = std.heap.ArenaAllocator.init(backing),
        };
    }

    pub fn allocator(self: *FrameArena) std.mem.Allocator {
        return self.arena.allocator();
    }

    /// フレーム終了時にすべてのメモリを解放
    pub fn endFrame(self: *FrameArena) void {
        _ = self.arena.reset(.retain_capacity);
        self.frame_count += 1;
    }

    pub fn deinit(self: *FrameArena) void {
        self.arena.deinit();
    }
};
```

---

### 6. レンダリング最適化

#### 6.1 増分レンダリング

```zig
// core/src/renderer/incremental.zig

/// 増分レンダリングスケジューラー
pub const IncrementalRenderer = struct {
    pending_updates: std.PriorityQueue(Update, void, comparePriority),
    deadline: i64,
    frame_budget_ms: u32 = 16,  // 60fps

    pub fn scheduleUpdate(self: *Self, update: Update) void {
        self.pending_updates.add(update);
    }

    /// requestIdleCallback スタイルの実行
    pub fn workLoop(self: *Self) void {
        while (self.pending_updates.count() > 0) {
            if (self.shouldYield()) {
                // 次のフレームに延期
                self.requestNextFrame();
                return;
            }

            const update = self.pending_updates.remove();
            self.processUpdate(update);
        }
    }

    fn shouldYield(self: *Self) bool {
        const now = std.time.milliTimestamp();
        return now >= self.deadline;
    }

    fn comparePriority(a: Update, b: Update) std.math.Order {
        // ユーザー入力 > アニメーション > データ更新 > バックグラウンド
        return std.math.order(a.priority, b.priority);
    }
};

pub const UpdatePriority = enum(u8) {
    immediate = 0,    // ユーザー入力
    animation = 1,    // アニメーション
    normal = 2,       // 通常更新
    low = 3,          // バックグラウンド
    idle = 4,         // アイドル時のみ
};
```

#### 6.2 仮想化リスト

```typescript
// bindings/typescript/src/components/VirtualList.ts

export interface VirtualListProps<T> {
  items: T[];
  itemHeight: number;
  overscan?: number;
  renderItem: (item: T, index: number) => Element;
}

export function VirtualList<T>({
  items,
  itemHeight,
  overscan = 3,
  renderItem,
}: VirtualListProps<T>) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);

  const containerHeight = containerRef.current?.clientHeight ?? 0;
  const totalHeight = items.length * itemHeight;

  // 表示範囲を計算
  const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);
  const endIndex = Math.min(
    items.length,
    Math.ceil((scrollTop + containerHeight) / itemHeight) + overscan
  );

  const visibleItems = items.slice(startIndex, endIndex);
  const offsetY = startIndex * itemHeight;

  return (
    <div
      ref={containerRef}
      style={{ height: '100%', overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((item, i) => renderItem(item, startIndex + i))}
        </div>
      </div>
    </div>
  );
}
```

---

### 7. プロファイリングツール

```typescript
// bindings/typescript/src/profiler.ts

export interface ProfilerResult {
  componentName: string;
  phase: 'mount' | 'update' | 'unmount';
  actualDuration: number;
  baseDuration: number;
  startTime: number;
  commitTime: number;
  interactions: Set<string>;
}

export class ZylixProfiler {
  private results: ProfilerResult[] = [];
  private enabled: boolean = false;

  enable(): void {
    this.enabled = true;
  }

  disable(): void {
    this.enabled = false;
  }

  onRender(result: ProfilerResult): void {
    if (!this.enabled) return;
    this.results.push(result);

    if (result.actualDuration > 16) {
      console.warn(
        `Slow render: ${result.componentName} took ${result.actualDuration.toFixed(2)}ms`
      );
    }
  }

  getReport(): ProfilerReport {
    const byComponent = new Map<string, ProfilerResult[]>();

    for (const result of this.results) {
      const existing = byComponent.get(result.componentName) ?? [];
      existing.push(result);
      byComponent.set(result.componentName, existing);
    }

    return {
      totalRenders: this.results.length,
      totalTime: this.results.reduce((sum, r) => sum + r.actualDuration, 0),
      slowestComponents: [...byComponent.entries()]
        .map(([name, results]) => ({
          name,
          avgDuration: results.reduce((s, r) => s + r.actualDuration, 0) / results.length,
          renderCount: results.length,
        }))
        .sort((a, b) => b.avgDuration - a.avgDuration)
        .slice(0, 10),
    };
  }

  clear(): void {
    this.results = [];
  }
}
```

---

## Part 2: ドキュメント充実 (v0.12.0)

### 8. ドキュメント構成

```
docs/
├── getting-started/
│   ├── installation.md
│   ├── quick-start.md
│   └── first-app.md
├── guides/
│   ├── components/
│   ├── state-management/
│   ├── routing/
│   ├── styling/
│   └── platform-specific/
├── api/
│   ├── core/
│   ├── components/
│   ├── hooks/
│   └── utilities/
├── tutorials/
│   ├── todo-app/
│   ├── chat-app/
│   ├── e-commerce/
│   └── dashboard/
├── examples/
│   └── (実行可能なサンプルコード)
└── blog/
    └── (リリースノート、技術記事)
```

### 9. APIドキュメント自動生成

```typescript
// tools/docgen/generator.ts

interface DocEntry {
  name: string;
  kind: 'function' | 'class' | 'type' | 'constant';
  signature: string;
  description: string;
  params?: ParamDoc[];
  returns?: TypeDoc;
  examples?: string[];
  since?: string;
  deprecated?: string;
}

export class DocGenerator {
  async generate(sourceDir: string, outputDir: string): Promise<void> {
    const files = await glob(`${sourceDir}/**/*.ts`);

    for (const file of files) {
      const ast = await parseTypeScript(file);
      const docs = this.extractDocs(ast);

      const markdown = this.renderMarkdown(docs);
      const outputPath = file.replace(sourceDir, outputDir).replace('.ts', '.md');
      await fs.writeFile(outputPath, markdown);
    }
  }

  private extractDocs(ast: AST): DocEntry[] {
    // JSDoc コメントを解析
    // TypeScript 型情報を抽出
    // 例: @example, @param, @returns, @since, @deprecated
  }

  private renderMarkdown(docs: DocEntry[]): string {
    return docs.map(doc => `
## ${doc.name}

${doc.description}

### Signature

\`\`\`typescript
${doc.signature}
\`\`\`

${doc.params ? this.renderParams(doc.params) : ''}
${doc.returns ? this.renderReturns(doc.returns) : ''}
${doc.examples ? this.renderExamples(doc.examples) : ''}
    `).join('\n---\n');
  }
}
```

### 10. インタラクティブプレイグラウンド

```typescript
// playground/src/Playground.tsx

interface PlaygroundProps {
  initialCode: string;
  language: 'typescript' | 'zig';
}

export function Playground({ initialCode, language }: PlaygroundProps) {
  const [code, setCode] = useState(initialCode);
  const [output, setOutput] = useState<string>('');
  const [error, setError] = useState<string | null>(null);

  const run = async () => {
    try {
      setError(null);

      if (language === 'typescript') {
        // TypeScript をブラウザでトランスパイル
        const transpiled = await transpileTypeScript(code);
        const result = await executeInSandbox(transpiled);
        setOutput(result);
      } else {
        // Zig は WASM にコンパイルして実行
        const wasm = await compileZigToWasm(code);
        const result = await executeWasm(wasm);
        setOutput(result);
      }
    } catch (e) {
      setError(e.message);
    }
  };

  return (
    <div className="playground">
      <div className="editor">
        <CodeEditor
          value={code}
          onChange={setCode}
          language={language}
        />
      </div>
      <div className="controls">
        <button onClick={run}>Run</button>
      </div>
      <div className="preview">
        {error ? (
          <div className="error">{error}</div>
        ) : (
          <div className="output" dangerouslySetInnerHTML={{ __html: output }} />
        )}
      </div>
    </div>
  );
}
```

---

### 11. 実装スケジュール

#### v0.11.0 (パフォーマンス)

| タスク | 期間 |
|--------|------|
| Virtual DOM 差分アルゴリズム最適化 | 2週間 |
| Tree Shaking 実装 | 1週間 |
| コード分割・遅延ロード | 1週間 |
| メモリ最適化 (プール、アリーナ) | 2週間 |
| 増分レンダリング | 2週間 |
| プロファイリングツール | 1週間 |
| ベンチマーク・テスト | 1週間 |

#### v0.12.0 (ドキュメント)

| タスク | 期間 |
|--------|------|
| APIドキュメント自動生成ツール | 2週間 |
| Getting Started ガイド | 1週間 |
| コンポーネントガイド | 2週間 |
| チュートリアル (4種類) | 4週間 |
| プレイグラウンド実装 | 2週間 |
| ビデオチュートリアル | 2週間 |
