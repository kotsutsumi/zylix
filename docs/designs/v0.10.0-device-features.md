# デバイス機能 & ジェスチャー設計書 (v0.10.0)

> **ステータス**: 計画中
> **予定リリース**: 2026年Q2
> **前提条件**: v0.9.0 完了

---

## 1. 概要

### 1.1 目的

クロスプラットフォームでデバイス機能（GPS、カメラ、センサー、通知）と高度なジェスチャー（ドラッグ&ドロップ、ピンチズーム、マルチタッチ）を統一APIで提供する。

### 1.2 設計原則

1. **プラットフォーム抽象化**: 各プラットフォームの差異を吸収
2. **権限管理**: 統一された権限リクエストフロー
3. **バッテリー効率**: センサー使用の最適化
4. **プライバシー**: 位置情報・カメラへの安全なアクセス

---

## 2. アーキテクチャ

### 2.1 レイヤー構成

```
┌─────────────────────────────────────────────────────────────┐
│                    Device API Layer                         │
│  (Geolocation, Camera, Sensors, Notifications, Gestures)   │
├─────────────────────────────────────────────────────────────┤
│                  Permission Manager                         │
│  (権限リクエスト、状態管理、フォールバック)                  │
├─────────────────────────────────────────────────────────────┤
│                Platform Abstraction Layer                   │
├──────────┬──────────┬──────────┬──────────┬────────────────┤
│  iOS     │ Android  │   Web    │  macOS   │ Windows/Linux  │
│ CoreLoc  │ Location │ Geoloc   │ CoreLoc  │ WinRT/GeoClue  │
│ AVFound  │ Camera2  │ MediaDev │ AVFound  │ DirectShow     │
│ CoreMot  │ Sensor   │ DevMot   │ CoreMot  │ WinSensor      │
│ UNNotif  │ FCM      │ WebPush  │ UNNotif  │ WNS/libnotify  │
└──────────┴──────────┴──────────┴──────────┴────────────────┘
```

---

## 3. 位置情報 (Geolocation)

### 3.1 API設計

```zig
// core/src/device/geolocation.zig

/// 位置情報
pub const Position = struct {
    latitude: f64,              // 緯度 (-90 ~ 90)
    longitude: f64,             // 経度 (-180 ~ 180)
    altitude: ?f64,             // 高度 (メートル)
    accuracy: f64,              // 水平精度 (メートル)
    altitude_accuracy: ?f64,    // 垂直精度 (メートル)
    heading: ?f64,              // 進行方向 (0-360度)
    speed: ?f64,                // 速度 (m/s)
    timestamp: i64,             // Unix timestamp (ms)
};

/// 位置情報オプション
pub const GeolocationOptions = struct {
    enable_high_accuracy: bool = false,
    timeout_ms: u32 = 10000,
    maximum_age_ms: u32 = 0,
    distance_filter: f32 = 0,  // 更新通知の最小距離 (メートル)
};

/// 位置情報API
pub const Geolocation = struct {
    backend: *Backend,

    const Self = @This();

    /// 現在位置を取得 (一回)
    pub fn getCurrentPosition(self: *Self, options: GeolocationOptions) !Position {
        return self.backend.getCurrentPosition(options);
    }

    /// 位置情報の監視を開始
    pub fn watchPosition(
        self: *Self,
        options: GeolocationOptions,
        callback: *const fn (result: PositionResult) void,
    ) WatchId {
        return self.backend.watchPosition(options, callback);
    }

    /// 監視を停止
    pub fn clearWatch(self: *Self, watch_id: WatchId) void {
        self.backend.clearWatch(watch_id);
    }
};

pub const PositionResult = union(enum) {
    success: Position,
    err: GeolocationError,
};

pub const GeolocationError = enum {
    permission_denied,
    position_unavailable,
    timeout,
};
```

### 3.2 TypeScript API

```typescript
// bindings/typescript/src/device/geolocation.ts

export interface Position {
  coords: {
    latitude: number;
    longitude: number;
    altitude: number | null;
    accuracy: number;
    altitudeAccuracy: number | null;
    heading: number | null;
    speed: number | null;
  };
  timestamp: number;
}

export interface GeolocationOptions {
  enableHighAccuracy?: boolean;
  timeout?: number;
  maximumAge?: number;
  distanceFilter?: number;
}

export class ZylixGeolocation {
  // 現在位置を取得
  static async getCurrentPosition(options?: GeolocationOptions): Promise<Position> {
    await Permission.request('location');
    return native.getCurrentPosition(options ?? {});
  }

  // 位置監視
  static watchPosition(
    callback: (position: Position) => void,
    errorCallback?: (error: GeolocationError) => void,
    options?: GeolocationOptions
  ): number {
    return native.watchPosition(callback, errorCallback, options ?? {});
  }

  // 監視停止
  static clearWatch(watchId: number): void {
    native.clearWatch(watchId);
  }

  // 2点間の距離計算 (Haversine formula)
  static distance(pos1: Position, pos2: Position): number {
    const R = 6371e3; // 地球の半径 (メートル)
    const lat1 = pos1.coords.latitude * Math.PI / 180;
    const lat2 = pos2.coords.latitude * Math.PI / 180;
    const dLat = (pos2.coords.latitude - pos1.coords.latitude) * Math.PI / 180;
    const dLon = (pos2.coords.longitude - pos1.coords.longitude) * Math.PI / 180;

    const a = Math.sin(dLat/2) ** 2 +
              Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon/2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
  }
}
```

### 3.3 使用例

```typescript
import { ZylixGeolocation, Permission } from '@zylix/device';

async function trackUserLocation() {
  // 権限確認
  const status = await Permission.check('location');
  if (status !== 'granted') {
    const result = await Permission.request('location');
    if (result !== 'granted') {
      console.log('位置情報の権限が必要です');
      return;
    }
  }

  // 現在位置取得
  const position = await ZylixGeolocation.getCurrentPosition({
    enableHighAccuracy: true,
  });
  console.log(`現在位置: ${position.coords.latitude}, ${position.coords.longitude}`);

  // 継続的な追跡
  const watchId = ZylixGeolocation.watchPosition(
    (pos) => {
      console.log(`位置更新: ${pos.coords.latitude}, ${pos.coords.longitude}`);
    },
    (error) => {
      console.error('位置取得エラー:', error);
    },
    { distanceFilter: 10 }  // 10メートル以上移動したら通知
  );

  // 1分後に停止
  setTimeout(() => {
    ZylixGeolocation.clearWatch(watchId);
  }, 60000);
}
```

---

## 4. カメラ

### 4.1 API設計

```zig
// core/src/device/camera.zig

/// カメラ設定
pub const CameraConfig = struct {
    facing: CameraFacing = .back,
    resolution: Resolution = .hd,
    flash_mode: FlashMode = .auto,
    focus_mode: FocusMode = .auto,
    zoom: f32 = 1.0,
};

pub const CameraFacing = enum { front, back };
pub const Resolution = enum { sd, hd, full_hd, @"4k" };
pub const FlashMode = enum { off, on, auto, torch };
pub const FocusMode = enum { auto, manual, continuous };

/// カメラ
pub const Camera = struct {
    backend: *Backend,
    config: CameraConfig,

    const Self = @This();

    /// カメラを開く
    pub fn open(config: CameraConfig) !Self {
        const backend = try Backend.openCamera(config);
        return Self{ .backend = backend, .config = config };
    }

    /// プレビュー開始
    pub fn startPreview(self: *Self, surface: *Surface) !void {
        return self.backend.startPreview(surface);
    }

    /// 写真撮影
    pub fn takePhoto(self: *Self) !Image {
        return self.backend.capturePhoto();
    }

    /// 動画撮影開始
    pub fn startRecording(self: *Self, output_path: []const u8) !void {
        return self.backend.startRecording(output_path);
    }

    /// 動画撮影停止
    pub fn stopRecording(self: *Self) !VideoFile {
        return self.backend.stopRecording();
    }

    /// カメラを閉じる
    pub fn close(self: *Self) void {
        self.backend.close();
    }
};
```

### 4.2 TypeScript API

```typescript
// bindings/typescript/src/device/camera.ts

export interface CameraConfig {
  facing?: 'front' | 'back';
  resolution?: '480p' | '720p' | '1080p' | '4k';
  flashMode?: 'off' | 'on' | 'auto' | 'torch';
}

export interface PhotoResult {
  uri: string;
  width: number;
  height: number;
  base64?: string;
}

export interface VideoResult {
  uri: string;
  duration: number;
  size: number;
}

export class ZylixCamera {
  private handle: number;

  static async open(config?: CameraConfig): Promise<ZylixCamera> {
    await Permission.request('camera');
    const handle = await native.openCamera(config ?? {});
    return new ZylixCamera(handle);
  }

  // プレビューを要素にアタッチ
  async attachPreview(element: HTMLElement): Promise<void> {
    return native.attachPreview(this.handle, element);
  }

  // 写真撮影
  async takePhoto(options?: { quality?: number; base64?: boolean }): Promise<PhotoResult> {
    return native.takePhoto(this.handle, options ?? {});
  }

  // 動画撮影
  async startRecording(): Promise<void> {
    await Permission.request('microphone');
    return native.startRecording(this.handle);
  }

  async stopRecording(): Promise<VideoResult> {
    return native.stopRecording(this.handle);
  }

  // フラッシュ制御
  async setFlashMode(mode: 'off' | 'on' | 'auto' | 'torch'): Promise<void> {
    return native.setFlashMode(this.handle, mode);
  }

  // ズーム (1.0 - maxZoom)
  async setZoom(level: number): Promise<void> {
    return native.setZoom(this.handle, level);
  }

  // カメラ切り替え
  async switchCamera(): Promise<void> {
    return native.switchCamera(this.handle);
  }

  async close(): Promise<void> {
    return native.closeCamera(this.handle);
  }

  // 利用可能なカメラ一覧
  static async getAvailableCameras(): Promise<CameraInfo[]> {
    return native.getAvailableCameras();
  }
}
```

### 4.3 使用例: QRコードスキャナー

```typescript
import { ZylixCamera } from '@zylix/device';
import { BarcodeScanner } from '@zylix/vision';

async function scanQRCode() {
  const camera = await ZylixCamera.open({ facing: 'back' });

  // プレビュー表示
  const previewElement = document.getElementById('camera-preview')!;
  await camera.attachPreview(previewElement);

  // フレームごとにQRコード検出
  const scanner = new BarcodeScanner();
  scanner.onDetect = (result) => {
    console.log('QRコード検出:', result.data);
    camera.close();
  };

  scanner.startScanning(camera);
}
```

---

## 5. センサー

### 5.1 API設計

```zig
// core/src/device/sensors.zig

/// 加速度センサーデータ
pub const AccelerometerData = struct {
    x: f32,  // m/s²
    y: f32,
    z: f32,
    timestamp: i64,
};

/// ジャイロスコープデータ
pub const GyroscopeData = struct {
    x: f32,  // rad/s
    y: f32,
    z: f32,
    timestamp: i64,
};

/// 磁力計データ
pub const MagnetometerData = struct {
    x: f32,  // μT (マイクロテスラ)
    y: f32,
    z: f32,
    timestamp: i64,
};

/// デバイスの向き
pub const DeviceOrientation = struct {
    alpha: f32,  // Z軸周りの回転 (0-360)
    beta: f32,   // X軸周りの回転 (-180-180)
    gamma: f32,  // Y軸周りの回転 (-90-90)
    timestamp: i64,
};

/// センサーマネージャー
pub const SensorManager = struct {
    /// 加速度センサー監視
    pub fn watchAccelerometer(
        interval_ms: u32,
        callback: *const fn (AccelerometerData) void,
    ) SubscriptionId;

    /// ジャイロスコープ監視
    pub fn watchGyroscope(
        interval_ms: u32,
        callback: *const fn (GyroscopeData) void,
    ) SubscriptionId;

    /// 磁力計監視
    pub fn watchMagnetometer(
        interval_ms: u32,
        callback: *const fn (MagnetometerData) void,
    ) SubscriptionId;

    /// デバイス向き監視
    pub fn watchOrientation(
        callback: *const fn (DeviceOrientation) void,
    ) SubscriptionId;

    /// 歩数計
    pub fn watchPedometer(
        callback: *const fn (steps: u32) void,
    ) SubscriptionId;

    /// 監視停止
    pub fn unsubscribe(id: SubscriptionId) void;
};
```

### 5.2 TypeScript API

```typescript
// bindings/typescript/src/device/sensors.ts

export interface AccelerometerData {
  x: number;
  y: number;
  z: number;
  timestamp: number;
}

export interface GyroscopeData {
  x: number;
  y: number;
  z: number;
  timestamp: number;
}

export interface DeviceOrientation {
  alpha: number;
  beta: number;
  gamma: number;
  absolute: boolean;
}

export class Sensors {
  // 加速度センサー
  static watchAccelerometer(
    callback: (data: AccelerometerData) => void,
    options?: { interval?: number }
  ): Subscription {
    return native.watchAccelerometer(callback, options?.interval ?? 100);
  }

  // ジャイロスコープ
  static watchGyroscope(
    callback: (data: GyroscopeData) => void,
    options?: { interval?: number }
  ): Subscription {
    return native.watchGyroscope(callback, options?.interval ?? 100);
  }

  // デバイス向き
  static watchOrientation(
    callback: (data: DeviceOrientation) => void
  ): Subscription {
    return native.watchOrientation(callback);
  }

  // 歩数計 (iOS/Android のみ)
  static async watchPedometer(
    callback: (steps: number) => void
  ): Promise<Subscription> {
    await Permission.request('motion');
    return native.watchPedometer(callback);
  }

  // 近接センサー
  static watchProximity(
    callback: (isNear: boolean) => void
  ): Subscription {
    return native.watchProximity(callback);
  }

  // 環境光センサー
  static watchAmbientLight(
    callback: (lux: number) => void
  ): Subscription {
    return native.watchAmbientLight(callback);
  }
}

export interface Subscription {
  unsubscribe(): void;
}
```

### 5.3 使用例: 歩数計アプリ

```typescript
import { Sensors, Permission } from '@zylix/device';

async function pedometerApp() {
  const status = await Permission.request('motion');
  if (status !== 'granted') return;

  let totalSteps = 0;

  const subscription = await Sensors.watchPedometer((steps) => {
    totalSteps = steps;
    document.getElementById('steps')!.textContent = `${steps} 歩`;

    // カロリー計算 (概算: 1歩 = 0.04 kcal)
    const calories = Math.round(steps * 0.04);
    document.getElementById('calories')!.textContent = `${calories} kcal`;
  });

  // アプリ終了時にクリーンアップ
  window.addEventListener('beforeunload', () => {
    subscription.unsubscribe();
  });
}
```

---

## 6. 通知

### 6.1 API設計

```zig
// core/src/device/notifications.zig

/// 通知
pub const Notification = struct {
    id: []const u8,
    title: []const u8,
    body: []const u8,
    data: ?std.json.Value = null,

    // 表示オプション
    icon: ?[]const u8 = null,
    image: ?[]const u8 = null,
    badge: ?u32 = null,
    sound: ?[]const u8 = null,

    // スケジュール
    trigger: ?NotificationTrigger = null,

    // アクション
    actions: []const NotificationAction = &.{},
};

pub const NotificationTrigger = union(enum) {
    immediate: void,
    time_interval: struct {
        seconds: u32,
        repeats: bool = false,
    },
    calendar: struct {
        year: ?u16 = null,
        month: ?u8 = null,
        day: ?u8 = null,
        hour: ?u8 = null,
        minute: ?u8 = null,
        repeats: bool = false,
    },
    location: struct {
        latitude: f64,
        longitude: f64,
        radius: f32,
        on_enter: bool = true,
        on_exit: bool = false,
    },
};

pub const NotificationAction = struct {
    id: []const u8,
    title: []const u8,
    destructive: bool = false,
    requires_authentication: bool = false,
};
```

### 6.2 TypeScript API

```typescript
// bindings/typescript/src/device/notifications.ts

export interface NotificationOptions {
  title: string;
  body: string;
  data?: Record<string, unknown>;
  icon?: string;
  image?: string;
  badge?: number;
  sound?: string | 'default';
  actions?: NotificationAction[];
}

export interface NotificationAction {
  id: string;
  title: string;
  destructive?: boolean;
}

export interface ScheduleOptions {
  at?: Date;
  repeat?: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';
}

export class Notifications {
  // ローカル通知
  static async show(options: NotificationOptions): Promise<string> {
    await Permission.request('notifications');
    return native.showNotification(options);
  }

  // スケジュール通知
  static async schedule(
    options: NotificationOptions,
    schedule: ScheduleOptions
  ): Promise<string> {
    await Permission.request('notifications');
    return native.scheduleNotification(options, schedule);
  }

  // 通知キャンセル
  static async cancel(id: string): Promise<void> {
    return native.cancelNotification(id);
  }

  // 全通知キャンセル
  static async cancelAll(): Promise<void> {
    return native.cancelAllNotifications();
  }

  // バッジ更新 (iOS)
  static async setBadge(count: number): Promise<void> {
    return native.setBadge(count);
  }

  // 通知タップイベント
  static onNotificationTap(
    callback: (notification: ReceivedNotification) => void
  ): Subscription {
    return native.onNotificationTap(callback);
  }

  // アクションタップイベント
  static onActionTap(
    callback: (actionId: string, notification: ReceivedNotification) => void
  ): Subscription {
    return native.onActionTap(callback);
  }

  // プッシュ通知トークン取得
  static async getPushToken(): Promise<string> {
    await Permission.request('notifications');
    return native.getPushToken();
  }

  // プッシュ通知受信イベント
  static onPushReceived(
    callback: (notification: ReceivedNotification) => void
  ): Subscription {
    return native.onPushReceived(callback);
  }
}
```

### 6.3 使用例: リマインダーアプリ

```typescript
import { Notifications, Permission } from '@zylix/device';

async function scheduleReminder() {
  // 権限リクエスト
  const status = await Permission.request('notifications');
  if (status !== 'granted') {
    alert('通知の権限が必要です');
    return;
  }

  // 30分後にリマインダー
  const notificationId = await Notifications.schedule(
    {
      title: 'リマインダー',
      body: '会議の時間です',
      sound: 'default',
      actions: [
        { id: 'snooze', title: '5分後に再通知' },
        { id: 'dismiss', title: '閉じる', destructive: true },
      ],
    },
    {
      at: new Date(Date.now() + 30 * 60 * 1000),
    }
  );

  console.log('通知スケジュール:', notificationId);

  // アクション処理
  Notifications.onActionTap((actionId, notification) => {
    if (actionId === 'snooze') {
      Notifications.schedule(
        { title: notification.title, body: notification.body },
        { at: new Date(Date.now() + 5 * 60 * 1000) }
      );
    }
  });
}
```

---

## 7. 権限管理

### 7.1 統一権限API

```typescript
// bindings/typescript/src/device/permission.ts

export type PermissionType =
  | 'camera'
  | 'microphone'
  | 'location'
  | 'locationAlways'
  | 'notifications'
  | 'photos'
  | 'contacts'
  | 'calendar'
  | 'motion'
  | 'bluetooth';

export type PermissionStatus =
  | 'granted'
  | 'denied'
  | 'undetermined'
  | 'restricted'  // iOS: parental controls
  | 'limited';    // iOS 14+: limited photo access

export class Permission {
  // 権限状態を確認
  static async check(permission: PermissionType): Promise<PermissionStatus> {
    return native.checkPermission(permission);
  }

  // 権限をリクエスト
  static async request(permission: PermissionType): Promise<PermissionStatus> {
    return native.requestPermission(permission);
  }

  // 複数権限を一括リクエスト
  static async requestMultiple(
    permissions: PermissionType[]
  ): Promise<Record<PermissionType, PermissionStatus>> {
    return native.requestMultiplePermissions(permissions);
  }

  // 設定画面を開く
  static async openSettings(): Promise<void> {
    return native.openAppSettings();
  }

  // 権限が必要な理由を説明 (iOS)
  static async shouldShowRationale(permission: PermissionType): Promise<boolean> {
    return native.shouldShowRationale(permission);
  }
}
```

### 7.2 プラットフォーム実装

```swift
// platforms/ios/Sources/ZylixDevice/Permission.swift

import AVFoundation
import CoreLocation
import Photos
import UserNotifications

public class PermissionManager {
    public static func check(_ type: PermissionType) async -> PermissionStatus {
        switch type {
        case .camera:
            return mapAVStatus(AVCaptureDevice.authorizationStatus(for: .video))
        case .microphone:
            return mapAVStatus(AVCaptureDevice.authorizationStatus(for: .audio))
        case .location:
            return mapCLStatus(CLLocationManager().authorizationStatus)
        case .photos:
            return mapPHStatus(PHPhotoLibrary.authorizationStatus(for: .readWrite))
        case .notifications:
            let settings = await UNUserNotificationCenter.current().notificationSettings()
            return mapUNStatus(settings.authorizationStatus)
        default:
            return .undetermined
        }
    }

    public static func request(_ type: PermissionType) async -> PermissionStatus {
        switch type {
        case .camera:
            let granted = await AVCaptureDevice.requestAccess(for: .video)
            return granted ? .granted : .denied
        case .notifications:
            do {
                let granted = try await UNUserNotificationCenter.current()
                    .requestAuthorization(options: [.alert, .sound, .badge])
                return granted ? .granted : .denied
            } catch {
                return .denied
            }
        // ... 他の権限
        default:
            return .undetermined
        }
    }
}
```

---

## 8. 高度なジェスチャー

### 8.1 ドラッグ&ドロップ

```zig
// core/src/gestures/drag_drop.zig

/// ドラッグ可能アイテム
pub const Draggable = struct {
    id: []const u8,
    data: std.json.Value,
    preview: ?*Element = null,

    // イベント
    on_drag_start: ?*const fn (*DragEvent) void = null,
    on_drag_move: ?*const fn (*DragEvent) void = null,
    on_drag_end: ?*const fn (*DragEvent) void = null,
};

/// ドロップターゲット
pub const DropTarget = struct {
    id: []const u8,
    accepts: []const []const u8,  // 受け入れ可能なデータタイプ

    on_drag_enter: ?*const fn (*DragEvent) void = null,
    on_drag_over: ?*const fn (*DragEvent) void = null,
    on_drag_leave: ?*const fn (*DragEvent) void = null,
    on_drop: ?*const fn (*DropEvent) void = null,
};

pub const DragEvent = struct {
    source_id: []const u8,
    position: Point,
    data: std.json.Value,
};

pub const DropEvent = struct {
    source_id: []const u8,
    target_id: []const u8,
    position: Point,
    data: std.json.Value,
};
```

### 8.2 TypeScript API

```typescript
// bindings/typescript/src/gestures/drag-drop.ts

export interface DraggableOptions {
  data: unknown;
  preview?: Element | (() => Element);
  dragHandle?: string;  // CSS selector
  delay?: number;       // 長押し時間 (モバイル)
  disabled?: boolean;
}

export interface DropTargetOptions {
  accepts?: string[];   // データタイプ
  onDragEnter?: (event: DragEvent) => void;
  onDragOver?: (event: DragEvent) => void;
  onDragLeave?: (event: DragEvent) => void;
  onDrop?: (event: DropEvent) => void;
}

// React Hook
export function useDraggable(options: DraggableOptions) {
  return {
    draggableProps: {
      'data-draggable': true,
      onPointerDown: handlePointerDown,
      onTouchStart: handleTouchStart,  // モバイル長押し
    },
    isDragging: boolean,
  };
}

export function useDropTarget(options: DropTargetOptions) {
  return {
    dropTargetProps: {
      'data-drop-target': true,
      onDragEnter: handleDragEnter,
      onDragOver: handleDragOver,
      onDragLeave: handleDragLeave,
      onDrop: handleDrop,
    },
    isOver: boolean,
    canDrop: boolean,
  };
}
```

### 8.3 使用例: カンバンボード

```typescript
import { useDraggable, useDropTarget } from '@zylix/gestures';

function KanbanCard({ task }) {
  const { draggableProps, isDragging } = useDraggable({
    data: { taskId: task.id },
    delay: 200,  // 200ms長押しでドラッグ開始
  });

  return (
    <div
      {...draggableProps}
      className={`card ${isDragging ? 'dragging' : ''}`}
    >
      {task.title}
    </div>
  );
}

function KanbanColumn({ status, tasks, onTaskMove }) {
  const { dropTargetProps, isOver } = useDropTarget({
    onDrop: (event) => {
      onTaskMove(event.data.taskId, status);
    },
  });

  return (
    <div
      {...dropTargetProps}
      className={`column ${isOver ? 'drag-over' : ''}`}
    >
      <h3>{status}</h3>
      {tasks.map(task => <KanbanCard key={task.id} task={task} />)}
    </div>
  );
}
```

### 8.4 ピンチズーム & 回転

```typescript
// bindings/typescript/src/gestures/multi-touch.ts

export interface PinchEvent {
  scale: number;       // 1.0 = 開始時
  rotation: number;    // ラジアン
  center: Point;       // ピンチの中心
  velocity: number;    // スケール変化速度
}

export interface PanEvent {
  translation: Point;
  velocity: Point;
  state: 'began' | 'changed' | 'ended' | 'cancelled';
}

export function usePinchZoom(options?: {
  minScale?: number;
  maxScale?: number;
  onPinchStart?: () => void;
  onPinchChange?: (event: PinchEvent) => void;
  onPinchEnd?: () => void;
}) {
  return {
    pinchProps: { /* ... */ },
    scale: number,
    rotation: number,
  };
}

export function usePanGesture(options?: {
  onPanStart?: (event: PanEvent) => void;
  onPan?: (event: PanEvent) => void;
  onPanEnd?: (event: PanEvent) => void;
}) {
  return {
    panProps: { /* ... */ },
    offset: Point,
  };
}
```

### 8.5 使用例: 画像ビューア

```typescript
import { usePinchZoom, usePanGesture } from '@zylix/gestures';

function ImageViewer({ src }) {
  const { pinchProps, scale, rotation } = usePinchZoom({
    minScale: 1,
    maxScale: 5,
  });

  const { panProps, offset } = usePanGesture();

  return (
    <div className="viewer" {...pinchProps} {...panProps}>
      <img
        src={src}
        style={{
          transform: `
            translate(${offset.x}px, ${offset.y}px)
            scale(${scale})
            rotate(${rotation}rad)
          `,
        }}
      />
    </div>
  );
}
```

---

## 9. プラットフォーム実装マトリクス

| 機能 | iOS | Android | Web | macOS | Windows | Linux |
|------|-----|---------|-----|-------|---------|-------|
| GPS | CoreLocation | FusedLocation | Geolocation API | CoreLocation | WinRT Location | GeoClue |
| カメラ | AVFoundation | Camera2 | MediaDevices | AVFoundation | MediaCapture | V4L2 |
| 加速度計 | CoreMotion | SensorManager | DeviceMotion | CoreMotion | WinSensor | - |
| ジャイロ | CoreMotion | SensorManager | DeviceOrientation | CoreMotion | WinSensor | - |
| 歩数計 | CoreMotion | SensorManager | - | - | - | - |
| ローカル通知 | UNNotification | NotificationManager | Notification API | UNNotification | ToastNotification | libnotify |
| プッシュ通知 | APNs | FCM | Web Push | APNs | WNS | - |
| ドラッグ&ドロップ | UIDrag/DropInteraction | DragEvent | Drag and Drop API | NSDraggingInfo | WinRT DragDrop | GTK DnD |

---

## 10. 実装スケジュール

### Phase 1: 権限管理 (1週間)
- [ ] 統一権限API
- [ ] iOS/Android/Web実装
- [ ] 権限フロー UI

### Phase 2: 位置情報 (2週間)
- [ ] Geolocation API
- [ ] バックグラウンド位置取得
- [ ] ジオフェンシング

### Phase 3: カメラ (2週間)
- [ ] カメラプレビュー
- [ ] 写真撮影
- [ ] 動画録画
- [ ] QRコードスキャン

### Phase 4: センサー (2週間)
- [ ] 加速度計/ジャイロ
- [ ] 磁力計
- [ ] 歩数計
- [ ] 近接/光センサー

### Phase 5: 通知 (2週間)
- [ ] ローカル通知
- [ ] スケジュール通知
- [ ] プッシュ通知 (iOS/Android)
- [ ] 通知アクション

### Phase 6: ジェスチャー (2週間)
- [ ] ドラッグ&ドロップ
- [ ] ピンチズーム
- [ ] 回転ジェスチャー
- [ ] マルチタッチ

### Phase 7: テスト & ドキュメント (1週間)
- [ ] 単体テスト
- [ ] 統合テスト
- [ ] APIドキュメント
- [ ] サンプルアプリ

---

## 11. 依存関係

### プラットフォーム依存

| プラットフォーム | フレームワーク/SDK |
|-----------------|-------------------|
| iOS | CoreLocation, AVFoundation, CoreMotion, UserNotifications |
| Android | FusedLocationProvider, Camera2, SensorManager, FCM |
| Web | Geolocation API, MediaDevices, DeviceMotion, Notification API |
| macOS | CoreLocation, AVFoundation, CoreMotion, UserNotifications |
| Windows | Windows.Devices.Geolocation, Windows.Media.Capture, WinSensor |
| Linux | GeoClue, V4L2, libnotify |
