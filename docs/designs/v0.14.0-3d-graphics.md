# 3Dグラフィックスエンジン設計書 (v0.14.0)

> **ステータス**: 計画中
> **予定リリース**: 2027年Q2
> **前提条件**: v0.13.0 完了

---

## 1. 概要

### 1.1 目的

Three.js / Babylon.js にインスパイアされたクロスプラットフォーム3Dグラフィックスエンジンを実装し、ゲーム、ビジュアライゼーション、AR/VR アプリケーションの基盤を提供する。

### 1.2 レンダリングバックエンド

| プラットフォーム | プライマリ | フォールバック |
|-----------------|-----------|---------------|
| iOS | Metal | OpenGL ES 3.0 |
| macOS | Metal | OpenGL 4.1 |
| Android | Vulkan | OpenGL ES 3.2 |
| Windows | DirectX 12 | Vulkan / OpenGL 4.6 |
| Linux | Vulkan | OpenGL 4.6 |
| Web | WebGPU | WebGL 2.0 |

---

## 2. アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                      Scene Graph                            │
│  (Node, Mesh, Light, Camera, Group, Transform)              │
├─────────────────────────────────────────────────────────────┤
│              Rendering Pipeline                             │
│  (Forward/Deferred, Shadows, Post-Processing)              │
├─────────────────────────────────────────────────────────────┤
│              Graphics Abstraction Layer                     │
│  (Buffer, Texture, Shader, RenderPass, Pipeline)           │
├─────────────────────────────────────────────────────────────┤
│                  Backend Implementations                    │
├──────────┬──────────┬──────────┬──────────┬────────────────┤
│  Metal   │ Vulkan   │ DirectX  │ WebGPU   │ OpenGL         │
└──────────┴──────────┴──────────┴──────────┴────────────────┘
```

---

## 3. シーングラフ

### 3.1 ノード構造

```zig
// core/src/graphics3d/scene/node.zig

/// シーンノードの基底
pub const Node = struct {
    id: u64,
    name: []const u8,

    // 階層構造
    parent: ?*Node,
    children: std.ArrayList(*Node),

    // トランスフォーム
    position: Vec3 = Vec3.zero(),
    rotation: Quaternion = Quaternion.identity(),
    scale: Vec3 = Vec3.one(),

    // キャッシュされた行列
    local_matrix: Mat4,
    world_matrix: Mat4,
    matrix_dirty: bool = true,

    // 可視性
    visible: bool = true,
    frustum_culled: bool = true,

    const Self = @This();

    pub fn addChild(self: *Self, child: *Node) void {
        child.parent = self;
        self.children.append(child);
        child.markWorldMatrixDirty();
    }

    pub fn removeChild(self: *Self, child: *Node) void {
        child.parent = null;
        // リストから削除
    }

    pub fn getWorldMatrix(self: *Self) Mat4 {
        if (self.matrix_dirty) {
            self.updateWorldMatrix();
        }
        return self.world_matrix;
    }

    fn updateWorldMatrix(self: *Self) void {
        self.local_matrix = Mat4.compose(self.position, self.rotation, self.scale);

        if (self.parent) |parent| {
            self.world_matrix = parent.getWorldMatrix().mul(self.local_matrix);
        } else {
            self.world_matrix = self.local_matrix;
        }

        self.matrix_dirty = false;

        // 子ノードも更新
        for (self.children.items) |child| {
            child.markWorldMatrixDirty();
        }
    }

    pub fn lookAt(self: *Self, target: Vec3, up: Vec3) void {
        const dir = target.sub(self.position).normalize();
        self.rotation = Quaternion.lookRotation(dir, up);
        self.markWorldMatrixDirty();
    }
};
```

### 3.2 メッシュ

```zig
// core/src/graphics3d/scene/mesh.zig

pub const Mesh = struct {
    base: Node,
    geometry: *Geometry,
    material: *Material,

    // インスタンシング
    instance_count: u32 = 1,
    instance_matrices: ?[]Mat4 = null,

    // ボーン (スケルタルアニメーション用)
    skeleton: ?*Skeleton = null,

    pub fn render(self: *Mesh, renderer: *Renderer, camera: *Camera) void {
        if (!self.base.visible) return;

        // フラスタムカリング
        if (self.base.frustum_culled) {
            const bounds = self.geometry.getBoundingSphere();
            const world_center = self.base.getWorldMatrix().transformPoint(bounds.center);
            if (!camera.frustum.containsSphere(world_center, bounds.radius)) {
                return;
            }
        }

        renderer.renderMesh(self, camera);
    }
};

pub const Geometry = struct {
    vertices: []Vertex,
    indices: []u32,
    vertex_buffer: *Buffer,
    index_buffer: *Buffer,

    // バウンディング
    bounding_box: AABB,
    bounding_sphere: Sphere,

    pub const Vertex = struct {
        position: Vec3,
        normal: Vec3,
        uv: Vec2,
        tangent: Vec4,  // w = handedness
        color: ?Vec4 = null,
        bone_indices: ?[4]u8 = null,
        bone_weights: ?Vec4 = null,
    };
};
```

### 3.3 カメラ

```zig
// core/src/graphics3d/scene/camera.zig

pub const Camera = struct {
    base: Node,
    projection_type: ProjectionType,

    // 透視投影
    fov: f32 = 60.0,  // 度
    aspect: f32 = 16.0 / 9.0,

    // 共通
    near: f32 = 0.1,
    far: f32 = 1000.0,

    // 正投影
    ortho_size: f32 = 10.0,

    // キャッシュ
    projection_matrix: Mat4,
    view_matrix: Mat4,
    frustum: Frustum,

    pub const ProjectionType = enum { perspective, orthographic };

    pub fn getProjectionMatrix(self: *Camera) Mat4 {
        return switch (self.projection_type) {
            .perspective => Mat4.perspective(
                std.math.degreesToRadians(self.fov),
                self.aspect,
                self.near,
                self.far,
            ),
            .orthographic => Mat4.orthographic(
                -self.ortho_size * self.aspect,
                self.ortho_size * self.aspect,
                -self.ortho_size,
                self.ortho_size,
                self.near,
                self.far,
            ),
        };
    }

    pub fn getViewMatrix(self: *Camera) Mat4 {
        return self.base.getWorldMatrix().inverse();
    }

    pub fn screenToWorld(self: *Camera, screen_pos: Vec2, depth: f32) Vec3 {
        const ndc = Vec3{
            .x = screen_pos.x * 2.0 - 1.0,
            .y = 1.0 - screen_pos.y * 2.0,
            .z = depth,
        };

        const inv_vp = self.getProjectionMatrix().mul(self.getViewMatrix()).inverse();
        return inv_vp.transformPoint(ndc);
    }

    pub fn worldToScreen(self: *Camera, world_pos: Vec3) Vec2 {
        const vp = self.getProjectionMatrix().mul(self.getViewMatrix());
        const clip = vp.transformPoint(world_pos);
        return Vec2{
            .x = (clip.x + 1.0) * 0.5,
            .y = (1.0 - clip.y) * 0.5,
        };
    }
};
```

### 3.4 ライト

```zig
// core/src/graphics3d/scene/light.zig

pub const Light = struct {
    base: Node,
    light_type: LightType,
    color: Vec3 = Vec3.one(),
    intensity: f32 = 1.0,

    // Directional / Spot
    direction: Vec3 = Vec3{ .x = 0, .y = -1, .z = 0 },

    // Point / Spot
    range: f32 = 10.0,
    attenuation: Attenuation = .{},

    // Spot
    inner_cone_angle: f32 = 30.0,  // 度
    outer_cone_angle: f32 = 45.0,

    // シャドウ
    cast_shadow: bool = false,
    shadow_map_size: u32 = 1024,
    shadow_bias: f32 = 0.005,

    pub const LightType = enum {
        directional,
        point,
        spot,
        ambient,
    };

    pub const Attenuation = struct {
        constant: f32 = 1.0,
        linear: f32 = 0.09,
        quadratic: f32 = 0.032,
    };
};
```

---

## 4. マテリアルシステム

### 4.1 PBRマテリアル

```zig
// core/src/graphics3d/materials/pbr.zig

/// 物理ベースレンダリングマテリアル
pub const PBRMaterial = struct {
    // 基本色
    base_color: Vec4 = Vec4{ .x = 1, .y = 1, .z = 1, .w = 1 },
    base_color_texture: ?*Texture = null,

    // メタリック・ラフネス
    metallic: f32 = 0.0,
    roughness: f32 = 0.5,
    metallic_roughness_texture: ?*Texture = null,

    // 法線マップ
    normal_texture: ?*Texture = null,
    normal_scale: f32 = 1.0,

    // エミッシブ
    emissive: Vec3 = Vec3.zero(),
    emissive_texture: ?*Texture = null,

    // オクルージョン
    ao_texture: ?*Texture = null,

    // アルファ
    alpha_mode: AlphaMode = .opaque,
    alpha_cutoff: f32 = 0.5,

    // レンダリング設定
    double_sided: bool = false,
    wireframe: bool = false,

    pub const AlphaMode = enum { opaque, mask, blend };

    pub fn getShader(self: *PBRMaterial) *Shader {
        // テクスチャの有無に基づいてシェーダーバリアントを選択
        var flags: u32 = 0;
        if (self.base_color_texture != null) flags |= 1;
        if (self.normal_texture != null) flags |= 2;
        if (self.metallic_roughness_texture != null) flags |= 4;
        if (self.emissive_texture != null) flags |= 8;
        if (self.ao_texture != null) flags |= 16;

        return ShaderCache.getPBRVariant(flags);
    }
};
```

### 4.2 シェーダー

```wgsl
// assets/shaders/pbr.wgsl

struct VertexInput {
    @location(0) position: vec3f,
    @location(1) normal: vec3f,
    @location(2) uv: vec2f,
    @location(3) tangent: vec4f,
};

struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) world_position: vec3f,
    @location(1) normal: vec3f,
    @location(2) uv: vec2f,
    @location(3) tangent: vec3f,
    @location(4) bitangent: vec3f,
};

struct CameraUniforms {
    view: mat4x4f,
    projection: mat4x4f,
    position: vec3f,
};

struct MaterialUniforms {
    base_color: vec4f,
    emissive: vec3f,
    metallic: f32,
    roughness: f32,
    normal_scale: f32,
};

@group(0) @binding(0) var<uniform> camera: CameraUniforms;
@group(1) @binding(0) var<uniform> material: MaterialUniforms;
@group(1) @binding(1) var base_color_texture: texture_2d<f32>;
@group(1) @binding(2) var normal_texture: texture_2d<f32>;
@group(1) @binding(3) var metallic_roughness_texture: texture_2d<f32>;
@group(1) @binding(4) var texture_sampler: sampler;

@vertex
fn vs_main(input: VertexInput, @builtin(instance_index) instance: u32) -> VertexOutput {
    var output: VertexOutput;

    let model = instances[instance].model;
    let world_pos = model * vec4f(input.position, 1.0);

    output.position = camera.projection * camera.view * world_pos;
    output.world_position = world_pos.xyz;
    output.normal = normalize((model * vec4f(input.normal, 0.0)).xyz);
    output.uv = input.uv;
    output.tangent = normalize((model * vec4f(input.tangent.xyz, 0.0)).xyz);
    output.bitangent = cross(output.normal, output.tangent) * input.tangent.w;

    return output;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4f {
    // テクスチャサンプリング
    let base_color = textureSample(base_color_texture, texture_sampler, input.uv) * material.base_color;
    let mr = textureSample(metallic_roughness_texture, texture_sampler, input.uv);
    let metallic = mr.b * material.metallic;
    let roughness = mr.g * material.roughness;

    // 法線マップ
    let tbn = mat3x3f(input.tangent, input.bitangent, input.normal);
    var normal = textureSample(normal_texture, texture_sampler, input.uv).xyz * 2.0 - 1.0;
    normal = normalize(tbn * (normal * vec3f(material.normal_scale, material.normal_scale, 1.0)));

    // PBR ライティング
    let view_dir = normalize(camera.position - input.world_position);
    var color = vec3f(0.0);

    // ライトループ
    for (var i = 0u; i < light_count; i++) {
        color += calculate_light(lights[i], input.world_position, normal, view_dir, base_color.rgb, metallic, roughness);
    }

    // IBL (Image-Based Lighting)
    color += calculate_ibl(normal, view_dir, base_color.rgb, metallic, roughness);

    // エミッシブ
    color += material.emissive;

    return vec4f(color, base_color.a);
}

fn calculate_light(light: Light, pos: vec3f, N: vec3f, V: vec3f, albedo: vec3f, metallic: f32, roughness: f32) -> vec3f {
    // Cook-Torrance BRDF
    var L: vec3f;
    var attenuation: f32 = 1.0;

    if (light.type == LIGHT_DIRECTIONAL) {
        L = -light.direction;
    } else {
        L = normalize(light.position - pos);
        let distance = length(light.position - pos);
        attenuation = 1.0 / (distance * distance);
    }

    let H = normalize(V + L);
    let NdotL = max(dot(N, L), 0.0);
    let NdotV = max(dot(N, V), 0.0);
    let NdotH = max(dot(N, H), 0.0);
    let HdotV = max(dot(H, V), 0.0);

    // Fresnel (Schlick approximation)
    let F0 = mix(vec3f(0.04), albedo, metallic);
    let F = F0 + (1.0 - F0) * pow(1.0 - HdotV, 5.0);

    // Distribution (GGX)
    let a = roughness * roughness;
    let a2 = a * a;
    let denom = NdotH * NdotH * (a2 - 1.0) + 1.0;
    let D = a2 / (PI * denom * denom);

    // Geometry (Smith GGX)
    let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
    let G1_V = NdotV / (NdotV * (1.0 - k) + k);
    let G1_L = NdotL / (NdotL * (1.0 - k) + k);
    let G = G1_V * G1_L;

    // Specular BRDF
    let specular = (D * F * G) / (4.0 * NdotV * NdotL + 0.0001);

    // Diffuse (Lambert)
    let kD = (1.0 - F) * (1.0 - metallic);
    let diffuse = kD * albedo / PI;

    return (diffuse + specular) * light.color * light.intensity * NdotL * attenuation;
}
```

---

## 5. モデルローダー

### 5.1 glTFローダー

```zig
// core/src/graphics3d/loaders/gltf.zig

pub const GLTFLoader = struct {
    pub fn load(path: []const u8) !*Scene {
        const data = try std.fs.cwd().readFileAlloc(allocator, path, 100 * 1024 * 1024);
        defer allocator.free(data);

        const gltf = try parseGLTF(data);
        return buildScene(gltf);
    }

    fn parseGLTF(data: []const u8) !GLTFData {
        // JSON パース
        // バイナリバッファ取得
        // ...
    }

    fn buildScene(gltf: GLTFData) !*Scene {
        var scene = try Scene.init();

        // メッシュ
        for (gltf.meshes) |mesh_data| {
            const geometry = try buildGeometry(mesh_data, gltf.buffers);
            const material = try buildMaterial(mesh_data.material, gltf.materials);
            const mesh = try Mesh.init(geometry, material);
            scene.add(mesh);
        }

        // スケルトン
        for (gltf.skins) |skin| {
            const skeleton = try buildSkeleton(skin, gltf.nodes);
            // メッシュにアタッチ
        }

        // アニメーション
        for (gltf.animations) |anim| {
            const clip = try buildAnimationClip(anim, gltf.accessors);
            scene.animations.append(clip);
        }

        return scene;
    }
};
```

### 5.2 TypeScript API

```typescript
// bindings/typescript/src/graphics3d/loaders.ts

export class GLTFLoader {
  static async load(url: string): Promise<GLTF> {
    const response = await fetch(url);
    const data = await response.arrayBuffer();
    return native.loadGLTF(data);
  }
}

export interface GLTF {
  scene: Scene;
  scenes: Scene[];
  animations: AnimationClip[];
  cameras: Camera[];
}

// 使用例
const gltf = await GLTFLoader.load('models/character.glb');
scene.add(gltf.scene);

const mixer = new AnimationMixer(gltf.scene);
const action = mixer.clipAction(gltf.animations[0]);
action.play();
```

---

## 6. レンダリングパイプライン

### 6.1 フォワードレンダリング

```zig
// core/src/graphics3d/renderer/forward.zig

pub const ForwardRenderer = struct {
    render_pass: *RenderPass,
    depth_buffer: *Texture,
    shadow_maps: std.ArrayList(*Texture),

    pub fn render(self: *Self, scene: *Scene, camera: *Camera) void {
        // 1. シャドウパス
        for (scene.lights.items) |light| {
            if (light.cast_shadow) {
                self.renderShadowMap(scene, light);
            }
        }

        // 2. 深度プリパス (オプション)
        if (self.use_depth_prepass) {
            self.renderDepthPrepass(scene, camera);
        }

        // 3. メインパス
        self.render_pass.begin();

        // 不透明オブジェクト (前から後ろ)
        const opaque_objects = self.sortByDistance(scene.getOpaqueObjects(), camera, .front_to_back);
        for (opaque_objects) |obj| {
            self.renderObject(obj, camera);
        }

        // スカイボックス
        if (scene.skybox) |skybox| {
            self.renderSkybox(skybox, camera);
        }

        // 透明オブジェクト (後ろから前)
        const transparent_objects = self.sortByDistance(scene.getTransparentObjects(), camera, .back_to_front);
        for (transparent_objects) |obj| {
            self.renderObject(obj, camera);
        }

        self.render_pass.end();

        // 4. ポストプロセス
        self.applyPostProcessing();
    }
};
```

### 6.2 ポストプロセス

```zig
// core/src/graphics3d/postprocess/effects.zig

pub const PostProcessPipeline = struct {
    effects: std.ArrayList(*PostProcessEffect),
    ping_pong_buffers: [2]*Texture,

    pub fn addEffect(self: *Self, effect: *PostProcessEffect) void {
        self.effects.append(effect);
    }

    pub fn process(self: *Self, input: *Texture) *Texture {
        var current = input;

        for (self.effects.items, 0..) |effect, i| {
            const output = self.ping_pong_buffers[i % 2];
            effect.apply(current, output);
            current = output;
        }

        return current;
    }
};

// エフェクト例
pub const BloomEffect = struct {
    threshold: f32 = 1.0,
    intensity: f32 = 1.0,
    blur_iterations: u32 = 5,

    pub fn apply(self: *Self, input: *Texture, output: *Texture) void {
        // 1. 明るい部分を抽出
        const bright = self.extractBright(input);

        // 2. ガウスブラー (ダウンサンプル + アップサンプル)
        var blurred = bright;
        for (0..self.blur_iterations) |_| {
            blurred = self.blur(blurred);
        }

        // 3. 合成
        self.composite(input, blurred, output, self.intensity);
    }
};

pub const ToneMappingEffect = struct {
    operator: ToneMappingOperator = .aces,
    exposure: f32 = 1.0,
    gamma: f32 = 2.2,

    pub const ToneMappingOperator = enum { reinhard, aces, filmic, uncharted2 };
};

pub const SSAOEffect = struct {
    radius: f32 = 0.5,
    bias: f32 = 0.025,
    kernel_size: u32 = 64,
};

pub const FXAAEffect = struct {};

pub const MotionBlurEffect = struct {
    samples: u32 = 16,
    intensity: f32 = 1.0,
};
```

---

## 7. TypeScript API

```typescript
// bindings/typescript/src/graphics3d/index.ts

export class Scene {
  readonly children: Object3D[] = [];
  background: Color | Texture | null = null;
  fog: Fog | null = null;

  add(...objects: Object3D[]): void;
  remove(...objects: Object3D[]): void;
  getObjectByName(name: string): Object3D | undefined;
  traverse(callback: (object: Object3D) => void): void;
}

export class Renderer {
  constructor(options?: RendererOptions);

  render(scene: Scene, camera: Camera): void;
  setSize(width: number, height: number): void;
  setPixelRatio(ratio: number): void;
  setClearColor(color: Color, alpha?: number): void;

  get domElement(): HTMLCanvasElement;
}

export class PerspectiveCamera extends Camera {
  constructor(fov?: number, aspect?: number, near?: number, far?: number);

  fov: number;
  aspect: number;
  updateProjectionMatrix(): void;
}

export class Mesh extends Object3D {
  constructor(geometry: Geometry, material: Material);

  geometry: Geometry;
  material: Material;
}

export class BoxGeometry extends Geometry {
  constructor(width?: number, height?: number, depth?: number);
}

export class SphereGeometry extends Geometry {
  constructor(radius?: number, widthSegments?: number, heightSegments?: number);
}

export class MeshStandardMaterial extends Material {
  color: Color;
  metalness: number;
  roughness: number;
  map: Texture | null;
  normalMap: Texture | null;
  emissive: Color;
  emissiveMap: Texture | null;
}
```

### 7.1 使用例

```typescript
import {
  Scene, Renderer, PerspectiveCamera,
  Mesh, BoxGeometry, MeshStandardMaterial,
  DirectionalLight, AmbientLight,
  OrbitControls,
} from '@zylix/graphics3d';

// シーン作成
const scene = new Scene();
scene.background = new Color(0x1a1a2e);

// カメラ
const camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 5);

// ライト
const dirLight = new DirectionalLight(0xffffff, 1);
dirLight.position.set(5, 10, 5);
dirLight.castShadow = true;
scene.add(dirLight);

const ambLight = new AmbientLight(0x404040, 0.5);
scene.add(ambLight);

// メッシュ
const geometry = new BoxGeometry(1, 1, 1);
const material = new MeshStandardMaterial({
  color: 0x00ff88,
  metalness: 0.5,
  roughness: 0.5,
});
const cube = new Mesh(geometry, material);
cube.castShadow = true;
scene.add(cube);

// レンダラー
const renderer = new Renderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// コントロール
const controls = new OrbitControls(camera, renderer.domElement);

// アニメーションループ
function animate() {
  requestAnimationFrame(animate);

  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;

  controls.update();
  renderer.render(scene, camera);
}

animate();
```

---

## 8. 実装スケジュール

| タスク | 期間 |
|--------|------|
| グラフィックス抽象化レイヤー | 3週間 |
| Metal/Vulkan/WebGPU バックエンド | 4週間 |
| シーングラフ | 2週間 |
| PBR マテリアル & シェーダー | 3週間 |
| glTF ローダー | 2週間 |
| シャドウマッピング | 2週間 |
| ポストプロセス | 2週間 |
| スケルタルアニメーション | 2週間 |
| テスト & 最適化 | 2週間 |

---

## 9. パフォーマンス目標

| メトリクス | 目標値 |
|-----------|--------|
| 三角形数 | 100万+ (60fps) |
| ドローコール | バッチングで最小化 |
| シャドウマップ | 4096x4096 |
| フレームタイム | <16.67ms (60fps) |
