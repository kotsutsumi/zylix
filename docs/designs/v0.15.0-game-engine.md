# ゲームエンジン設計書 (v0.15.0)

> **ステータス**: 計画中
> **予定リリース**: 2027年Q3
> **前提条件**: v0.14.0 完了

---

## 1. 概要

### 1.1 目的

PIXI.js / Phaser にインスパイアされた2Dゲームエンジンと Matter.js スタイルの物理エンジン、およびオーディオシステムを統合し、クロスプラットフォームゲーム開発の包括的な基盤を提供する。

### 1.2 コアコンポーネント

| コンポーネント | 説明 | 参考実装 |
|--------------|------|---------|
| 2Dレンダラー | スプライト、タイルマップ、パーティクル | PIXI.js |
| 物理エンジン | 剛体、衝突検出、コンストレイント | Matter.js, Box2D |
| オーディオ | 効果音、BGM、ストリーミング | Howler.js |
| ECS | エンティティ・コンポーネント・システム | Bevy, Legion |
| シーン管理 | シーン遷移、レイヤー管理 | Phaser |

### 1.3 レンダリングバックエンド

| プラットフォーム | 2D レンダラー |
|-----------------|--------------|
| iOS/macOS | Metal 2D (Sprite batching) |
| Android | Vulkan 2D / OpenGL ES 3.0 |
| Windows | DirectX 11 2D / Vulkan |
| Linux | Vulkan 2D / OpenGL 4.6 |
| Web | WebGPU 2D / WebGL 2.0 / Canvas 2D |

---

## 2. アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                     Game Application                        │
│  (Scenes, Entities, Components, Systems, Scripts)          │
├─────────────────────────────────────────────────────────────┤
│                   Entity-Component-System                   │
│  (World, Entity, Component, System, Query, Schedule)       │
├──────────────────────┬──────────────────────┬──────────────┤
│   2D Renderer        │   Physics Engine     │ Audio Engine │
│  (Sprite, Tilemap,   │  (RigidBody, Shape,  │ (Source,     │
│   Particles, Text)   │   Collision, Joint)  │  Listener)   │
├──────────────────────┴──────────────────────┴──────────────┤
│                    Scene Management                         │
│  (Scene, Layer, Camera2D, Transition)                      │
├─────────────────────────────────────────────────────────────┤
│                    Resource Management                      │
│  (AssetLoader, TextureAtlas, AudioBank, Prefab)            │
├─────────────────────────────────────────────────────────────┤
│               Graphics Backend (from v0.14.0)               │
├──────────┬──────────┬──────────┬──────────┬────────────────┤
│  Metal   │ Vulkan   │ DirectX  │ WebGPU   │ OpenGL         │
└──────────┴──────────┴──────────┴──────────┴────────────────┘
```

---

## 3. Entity-Component-System (ECS)

### 3.1 World と Entity

```zig
// core/src/game/ecs/world.zig

/// ECS ワールド - すべてのエンティティとコンポーネントを管理
pub const World = struct {
    entities: EntityStorage,
    components: ComponentStorage,
    resources: ResourceStorage,
    systems: SystemSchedule,

    // アーキタイプベースのストレージ
    archetypes: std.ArrayList(Archetype),
    entity_archetype_map: std.AutoHashMap(Entity, ArchetypeId),

    const Self = @This();

    pub fn init(allocator: Allocator) !*Self {
        const world = try allocator.create(Self);
        world.* = .{
            .entities = EntityStorage.init(allocator),
            .components = ComponentStorage.init(allocator),
            .resources = ResourceStorage.init(allocator),
            .systems = SystemSchedule.init(allocator),
            .archetypes = std.ArrayList(Archetype).init(allocator),
            .entity_archetype_map = std.AutoHashMap(Entity, ArchetypeId).init(allocator),
        };
        return world;
    }

    /// 新しいエンティティを生成
    pub fn spawn(self: *Self) EntityBuilder {
        const entity = self.entities.create();
        return EntityBuilder.init(self, entity);
    }

    /// 複数エンティティをバッチ生成
    pub fn spawnBatch(self: *Self, count: usize) []Entity {
        return self.entities.createBatch(count);
    }

    /// エンティティを削除
    pub fn despawn(self: *Self, entity: Entity) void {
        self.components.removeAll(entity);
        self.entities.destroy(entity);
    }

    /// コンポーネントを取得
    pub fn get(self: *Self, entity: Entity, comptime T: type) ?*T {
        return self.components.get(entity, T);
    }

    /// コンポーネントを追加
    pub fn insert(self: *Self, entity: Entity, component: anytype) void {
        self.components.insert(entity, component);
        self.updateArchetype(entity);
    }

    /// リソースを取得
    pub fn resource(self: *Self, comptime T: type) ?*T {
        return self.resources.get(T);
    }

    /// システムを実行
    pub fn update(self: *Self, delta_time: f32) void {
        self.resources.insert(DeltaTime{ .value = delta_time });
        self.systems.run(self);
    }
};

/// エンティティID
pub const Entity = struct {
    id: u32,
    generation: u32,

    pub const INVALID = Entity{ .id = std.math.maxInt(u32), .generation = 0 };

    pub fn isValid(self: Entity) bool {
        return self.id != std.math.maxInt(u32);
    }
};

/// エンティティビルダー (fluent API)
pub const EntityBuilder = struct {
    world: *World,
    entity: Entity,

    pub fn with(self: *EntityBuilder, component: anytype) *EntityBuilder {
        self.world.insert(self.entity, component);
        return self;
    }

    pub fn build(self: *EntityBuilder) Entity {
        return self.entity;
    }
};
```

### 3.2 コンポーネント

```zig
// core/src/game/ecs/components.zig

/// トランスフォームコンポーネント (2D)
pub const Transform2D = struct {
    position: Vec2 = Vec2.zero(),
    rotation: f32 = 0.0,  // ラジアン
    scale: Vec2 = Vec2.one(),

    // キャッシュ
    local_matrix: Mat3 = Mat3.identity(),
    world_matrix: Mat3 = Mat3.identity(),
    dirty: bool = true,

    pub fn getWorldMatrix(self: *Transform2D, parent: ?*const Transform2D) Mat3 {
        if (self.dirty) {
            self.local_matrix = Mat3.compose2D(self.position, self.rotation, self.scale);
            if (parent) |p| {
                self.world_matrix = p.world_matrix.mul(self.local_matrix);
            } else {
                self.world_matrix = self.local_matrix;
            }
            self.dirty = false;
        }
        return self.world_matrix;
    }

    pub fn translate(self: *Transform2D, delta: Vec2) void {
        self.position = self.position.add(delta);
        self.dirty = true;
    }

    pub fn rotate(self: *Transform2D, angle: f32) void {
        self.rotation += angle;
        self.dirty = true;
    }
};

/// スプライトコンポーネント
pub const Sprite = struct {
    texture: *Texture,
    region: ?TextureRegion = null,
    color: Color = Color.white(),
    anchor: Vec2 = Vec2{ .x = 0.5, .y = 0.5 },
    flip_x: bool = false,
    flip_y: bool = false,
    z_index: i32 = 0,
    visible: bool = true,
};

/// リジッドボディコンポーネント
pub const RigidBody2D = struct {
    body_type: BodyType = .dynamic,
    velocity: Vec2 = Vec2.zero(),
    angular_velocity: f32 = 0.0,
    mass: f32 = 1.0,
    inertia: f32 = 1.0,
    gravity_scale: f32 = 1.0,
    linear_damping: f32 = 0.0,
    angular_damping: f32 = 0.0,
    fixed_rotation: bool = false,
    continuous: bool = false,

    pub const BodyType = enum { static, kinematic, dynamic };
};

/// コライダーコンポーネント
pub const Collider2D = struct {
    shape: Shape,
    offset: Vec2 = Vec2.zero(),
    is_sensor: bool = false,
    friction: f32 = 0.2,
    restitution: f32 = 0.0,
    density: f32 = 1.0,
    collision_layer: u16 = 0x0001,
    collision_mask: u16 = 0xFFFF,

    pub const Shape = union(enum) {
        circle: struct { radius: f32 },
        box: struct { half_extents: Vec2 },
        polygon: struct { vertices: []const Vec2 },
        capsule: struct { radius: f32, height: f32 },
    };
};

/// オーディオソースコンポーネント
pub const AudioSource = struct {
    clip: ?*AudioClip = null,
    volume: f32 = 1.0,
    pitch: f32 = 1.0,
    loop: bool = false,
    spatial: bool = false,
    min_distance: f32 = 1.0,
    max_distance: f32 = 100.0,
    rolloff: Rolloff = .linear,
    state: State = .stopped,

    pub const Rolloff = enum { linear, logarithmic, custom };
    pub const State = enum { stopped, playing, paused };
};

/// アニメーションコンポーネント
pub const SpriteAnimator = struct {
    animations: std.StringHashMap(*SpriteAnimation),
    current: ?[]const u8 = null,
    frame_index: usize = 0,
    elapsed: f32 = 0.0,
    playing: bool = false,
    loop: bool = true,
};

/// タグコンポーネント (マーカー)
pub const Player = struct {};
pub const Enemy = struct {};
pub const Bullet = struct {};
pub const Collectible = struct {};
```

### 3.3 システム

```zig
// core/src/game/ecs/systems.zig

/// システムトレイト
pub fn System(comptime Context: type) type {
    return struct {
        run_fn: *const fn (*Context) void,

        pub fn run(self: @This(), ctx: *Context) void {
            self.run_fn(ctx);
        }
    };
}

/// クエリ - コンポーネントの組み合わせでエンティティを検索
pub fn Query(comptime Components: type) type {
    return struct {
        world: *World,

        pub fn iter(self: @This()) Iterator {
            return Iterator.init(self.world);
        }

        pub const Iterator = struct {
            // ...イテレータ実装
        };
    };
}

/// 物理システム
pub const PhysicsSystem = struct {
    pub fn run(world: *World) void {
        const physics = world.resource(PhysicsWorld2D) orelse return;
        const delta = world.resource(DeltaTime).?.value;

        // 物理シミュレーションステップ
        physics.step(delta);

        // トランスフォームを同期
        var query = Query(struct { transform: *Transform2D, body: *RigidBody2D }).init(world);
        var iter = query.iter();
        while (iter.next()) |components| {
            components.transform.position = physics.getPosition(components.body);
            components.transform.rotation = physics.getRotation(components.body);
        }
    }
};

/// スプライトレンダリングシステム
pub const SpriteRenderSystem = struct {
    pub fn run(world: *World) void {
        const renderer = world.resource(Renderer2D) orelse return;
        const camera = world.resource(Camera2D) orelse return;

        // スプライトを収集してソート
        var sprites = std.ArrayList(SpriteInstance).init(world.allocator);
        defer sprites.deinit();

        var query = Query(struct { transform: *Transform2D, sprite: *Sprite }).init(world);
        var iter = query.iter();
        while (iter.next()) |components| {
            if (!components.sprite.visible) continue;
            sprites.append(.{
                .transform = components.transform,
                .sprite = components.sprite,
            }) catch continue;
        }

        // Z-index でソート
        std.sort.sort(SpriteInstance, sprites.items, {}, struct {
            fn lessThan(_: void, a: SpriteInstance, b: SpriteInstance) bool {
                return a.sprite.z_index < b.sprite.z_index;
            }
        }.lessThan);

        // バッチレンダリング
        renderer.begin(camera);
        for (sprites.items) |instance| {
            renderer.drawSprite(instance.sprite, instance.transform.getWorldMatrix(null));
        }
        renderer.end();
    }
};

/// アニメーションシステム
pub const AnimationSystem = struct {
    pub fn run(world: *World) void {
        const delta = world.resource(DeltaTime).?.value;

        var query = Query(struct { animator: *SpriteAnimator, sprite: *Sprite }).init(world);
        var iter = query.iter();
        while (iter.next()) |components| {
            if (!components.animator.playing) continue;

            components.animator.elapsed += delta;
            const anim = components.animator.animations.get(components.animator.current.?) orelse continue;

            if (components.animator.elapsed >= anim.frame_duration) {
                components.animator.elapsed = 0;
                components.animator.frame_index += 1;

                if (components.animator.frame_index >= anim.frames.len) {
                    if (components.animator.loop) {
                        components.animator.frame_index = 0;
                    } else {
                        components.animator.playing = false;
                        components.animator.frame_index = anim.frames.len - 1;
                    }
                }
            }

            // スプライトのテクスチャ領域を更新
            components.sprite.region = anim.frames[components.animator.frame_index];
        }
    }
};

/// オーディオシステム
pub const AudioSystem = struct {
    pub fn run(world: *World) void {
        const audio = world.resource(AudioEngine) orelse return;
        const listener = world.resource(AudioListener) orelse return;

        var query = Query(struct { source: *AudioSource, transform: *Transform2D }).init(world);
        var iter = query.iter();
        while (iter.next()) |components| {
            if (components.source.spatial) {
                audio.updateSourcePosition(
                    components.source,
                    components.transform.position,
                    listener.position,
                );
            }
        }
    }
};
```

### 3.4 スケジュール

```zig
// core/src/game/ecs/schedule.zig

/// システム実行スケジュール
pub const Schedule = struct {
    stages: std.ArrayList(Stage),

    pub const Stage = struct {
        name: []const u8,
        systems: std.ArrayList(*System),
        parallel: bool = false,
    };

    /// ビルトインステージ
    pub const PreUpdate = "pre_update";
    pub const Update = "update";
    pub const PostUpdate = "post_update";
    pub const PreRender = "pre_render";
    pub const Render = "render";
    pub const PostRender = "post_render";

    pub fn addSystem(self: *Schedule, stage: []const u8, system: anytype) void {
        // ステージにシステムを追加
    }

    pub fn run(self: *Schedule, world: *World) void {
        for (self.stages.items) |stage| {
            if (stage.parallel) {
                // 並列実行
                self.runParallel(stage.systems.items, world);
            } else {
                // 順次実行
                for (stage.systems.items) |system| {
                    system.run(world);
                }
            }
        }
    }
};

/// 一般的なゲームスケジュール
pub fn createDefaultSchedule() Schedule {
    var schedule = Schedule.init();

    // Pre-Update: 入力処理
    schedule.addSystem(Schedule.PreUpdate, InputSystem);

    // Update: ゲームロジック
    schedule.addSystem(Schedule.Update, PhysicsSystem);
    schedule.addSystem(Schedule.Update, AnimationSystem);
    schedule.addSystem(Schedule.Update, AudioSystem);

    // Render: 描画
    schedule.addSystem(Schedule.Render, SpriteRenderSystem);
    schedule.addSystem(Schedule.Render, TilemapRenderSystem);
    schedule.addSystem(Schedule.Render, ParticleRenderSystem);
    schedule.addSystem(Schedule.Render, UIRenderSystem);

    return schedule;
}
```

---

## 4. 2Dレンダラー

### 4.1 スプライトバッチ

```zig
// core/src/game/renderer/sprite_batch.zig

/// 高効率スプライトバッチレンダラー
pub const SpriteBatch = struct {
    vertices: []Vertex,
    indices: []u32,
    vertex_count: usize = 0,
    index_count: usize = 0,

    current_texture: ?*Texture = null,
    batch_count: usize = 0,

    vertex_buffer: *Buffer,
    index_buffer: *Buffer,
    pipeline: *RenderPipeline,

    const MAX_SPRITES = 10000;
    const VERTICES_PER_SPRITE = 4;
    const INDICES_PER_SPRITE = 6;

    pub const Vertex = struct {
        position: Vec2,
        uv: Vec2,
        color: u32,  // packed RGBA
    };

    pub fn init(device: *Device) !*SpriteBatch {
        const batch = try allocator.create(SpriteBatch);

        batch.vertices = try allocator.alloc(Vertex, MAX_SPRITES * VERTICES_PER_SPRITE);
        batch.indices = try allocator.alloc(u32, MAX_SPRITES * INDICES_PER_SPRITE);

        // インデックスを事前生成
        var i: usize = 0;
        var v: u32 = 0;
        while (i < MAX_SPRITES) : (i += 1) {
            batch.indices[i * 6 + 0] = v + 0;
            batch.indices[i * 6 + 1] = v + 1;
            batch.indices[i * 6 + 2] = v + 2;
            batch.indices[i * 6 + 3] = v + 2;
            batch.indices[i * 6 + 4] = v + 3;
            batch.indices[i * 6 + 5] = v + 0;
            v += 4;
        }

        batch.vertex_buffer = try device.createBuffer(.{
            .size = @sizeOf(Vertex) * MAX_SPRITES * VERTICES_PER_SPRITE,
            .usage = .{ .vertex = true, .copy_dst = true },
        });

        batch.index_buffer = try device.createBuffer(.{
            .size = @sizeOf(u32) * MAX_SPRITES * INDICES_PER_SPRITE,
            .usage = .{ .index = true },
            .initial_data = std.mem.sliceAsBytes(batch.indices),
        });

        return batch;
    }

    pub fn begin(self: *SpriteBatch, camera: *Camera2D) void {
        self.vertex_count = 0;
        self.index_count = 0;
        self.batch_count = 0;
        self.current_texture = null;

        // カメラ行列を設定
        self.pipeline.setUniform("u_view_projection", camera.getViewProjectionMatrix());
    }

    pub fn draw(self: *SpriteBatch, sprite: *const Sprite, transform: Mat3) void {
        // テクスチャが変わったらフラッシュ
        if (self.current_texture != sprite.texture) {
            self.flush();
            self.current_texture = sprite.texture;
        }

        // バッファが満杯ならフラッシュ
        if (self.vertex_count >= MAX_SPRITES * VERTICES_PER_SPRITE) {
            self.flush();
        }

        // 頂点を追加
        const region = sprite.region orelse TextureRegion.full(sprite.texture);
        const size = Vec2{
            .x = @intToFloat(f32, region.width),
            .y = @intToFloat(f32, region.height),
        };
        const anchor = sprite.anchor;
        const color = sprite.color.toPackedRGBA();

        // 4頂点
        const positions = [4]Vec2{
            Vec2{ .x = -anchor.x * size.x, .y = -anchor.y * size.y },
            Vec2{ .x = (1.0 - anchor.x) * size.x, .y = -anchor.y * size.y },
            Vec2{ .x = (1.0 - anchor.x) * size.x, .y = (1.0 - anchor.y) * size.y },
            Vec2{ .x = -anchor.x * size.x, .y = (1.0 - anchor.y) * size.y },
        };

        var uvs = [4]Vec2{
            Vec2{ .x = region.u0, .y = region.v0 },
            Vec2{ .x = region.u1, .y = region.v0 },
            Vec2{ .x = region.u1, .y = region.v1 },
            Vec2{ .x = region.u0, .y = region.v1 },
        };

        if (sprite.flip_x) {
            std.mem.swap(f32, &uvs[0].x, &uvs[1].x);
            std.mem.swap(f32, &uvs[2].x, &uvs[3].x);
        }
        if (sprite.flip_y) {
            std.mem.swap(f32, &uvs[0].y, &uvs[3].y);
            std.mem.swap(f32, &uvs[1].y, &uvs[2].y);
        }

        for (0..4) |i| {
            const world_pos = transform.transformPoint(positions[i]);
            self.vertices[self.vertex_count] = .{
                .position = world_pos,
                .uv = uvs[i],
                .color = color,
            };
            self.vertex_count += 1;
        }

        self.index_count += 6;
    }

    pub fn flush(self: *SpriteBatch) void {
        if (self.vertex_count == 0) return;

        // 頂点バッファを更新
        self.vertex_buffer.writeData(0, std.mem.sliceAsBytes(self.vertices[0..self.vertex_count]));

        // 描画
        self.pipeline.setTexture("u_texture", self.current_texture.?);
        self.pipeline.draw(self.vertex_buffer, self.index_buffer, self.index_count);

        self.vertex_count = 0;
        self.index_count = 0;
        self.batch_count += 1;
    }

    pub fn end(self: *SpriteBatch) void {
        self.flush();
    }
};
```

### 4.2 タイルマップ

```zig
// core/src/game/renderer/tilemap.zig

/// タイルマップレンダラー
pub const Tilemap = struct {
    width: u32,
    height: u32,
    tile_width: u32,
    tile_height: u32,
    layers: std.ArrayList(*TileLayer),
    tilesets: std.ArrayList(*Tileset),

    pub const TileLayer = struct {
        name: []const u8,
        data: []u32,  // タイルID (0 = 空)
        visible: bool = true,
        opacity: f32 = 1.0,
        offset: Vec2 = Vec2.zero(),

        // 衝突レイヤー
        collision: bool = false,
    };

    pub const Tileset = struct {
        name: []const u8,
        texture: *Texture,
        tile_width: u32,
        tile_height: u32,
        first_gid: u32,
        tile_count: u32,
        columns: u32,

        pub fn getTileRegion(self: *Tileset, gid: u32) ?TextureRegion {
            if (gid < self.first_gid or gid >= self.first_gid + self.tile_count) {
                return null;
            }

            const local_id = gid - self.first_gid;
            const col = local_id % self.columns;
            const row = local_id / self.columns;

            return TextureRegion{
                .texture = self.texture,
                .x = col * self.tile_width,
                .y = row * self.tile_height,
                .width = self.tile_width,
                .height = self.tile_height,
            };
        }
    };

    /// TMX (Tiled) ファイルを読み込み
    pub fn loadTMX(path: []const u8) !*Tilemap {
        const data = try std.fs.cwd().readFileAlloc(allocator, path, 10 * 1024 * 1024);
        defer allocator.free(data);

        // XML パース
        const xml = try xml.parse(data);
        return parseTMX(xml);
    }

    /// 可視タイルのみをカリングして描画
    pub fn render(self: *Tilemap, batch: *SpriteBatch, camera: *Camera2D) void {
        const view_bounds = camera.getViewBounds();

        // 可視タイル範囲を計算
        const start_x = @max(0, @floatToInt(i32, view_bounds.min.x / @intToFloat(f32, self.tile_width)));
        const start_y = @max(0, @floatToInt(i32, view_bounds.min.y / @intToFloat(f32, self.tile_height)));
        const end_x = @min(self.width, @floatToInt(u32, view_bounds.max.x / @intToFloat(f32, self.tile_width)) + 1);
        const end_y = @min(self.height, @floatToInt(u32, view_bounds.max.y / @intToFloat(f32, self.tile_height)) + 1);

        for (self.layers.items) |layer| {
            if (!layer.visible) continue;

            var y = start_y;
            while (y < end_y) : (y += 1) {
                var x = start_x;
                while (x < end_x) : (x += 1) {
                    const tile_id = layer.data[@intCast(usize, y * self.width + x)];
                    if (tile_id == 0) continue;

                    // タイルセットからリージョンを取得
                    const region = self.getTileRegion(tile_id) orelse continue;

                    // 描画
                    const world_pos = Vec2{
                        .x = @intToFloat(f32, x) * @intToFloat(f32, self.tile_width) + layer.offset.x,
                        .y = @intToFloat(f32, y) * @intToFloat(f32, self.tile_height) + layer.offset.y,
                    };

                    batch.drawRegion(region, world_pos, Color.white().withAlpha(layer.opacity));
                }
            }
        }
    }

    fn getTileRegion(self: *Tilemap, gid: u32) ?TextureRegion {
        for (self.tilesets.items) |tileset| {
            if (tileset.getTileRegion(gid)) |region| {
                return region;
            }
        }
        return null;
    }
};
```

### 4.3 パーティクルシステム

```zig
// core/src/game/renderer/particles.zig

/// パーティクルエミッター
pub const ParticleEmitter = struct {
    // エミッター設定
    texture: *Texture,
    max_particles: u32 = 1000,
    emission_rate: f32 = 100.0,  // particles/sec
    duration: f32 = -1.0,  // -1 = 無限
    loop: bool = true,

    // 初期値 (ランダム範囲)
    start_lifetime: Range(f32) = .{ .min = 1.0, .max = 2.0 },
    start_speed: Range(f32) = .{ .min = 50.0, .max = 100.0 },
    start_size: Range(f32) = .{ .min = 10.0, .max = 20.0 },
    start_rotation: Range(f32) = .{ .min = 0.0, .max = 2.0 * std.math.pi },
    start_color: Range(Color) = .{ .min = Color.white(), .max = Color.white() },

    // 時間経過による変化
    size_over_lifetime: ?*Curve = null,
    color_over_lifetime: ?*Gradient = null,
    velocity_over_lifetime: ?*Curve = null,

    // 形状
    shape: EmitterShape = .{ .cone = .{ .angle = 45.0, .radius = 0.0 } },

    // 物理
    gravity: Vec2 = Vec2.zero(),

    // ランタイム状態
    particles: []Particle,
    active_count: usize = 0,
    emit_timer: f32 = 0.0,
    elapsed: f32 = 0.0,
    playing: bool = true,

    pub const EmitterShape = union(enum) {
        point: void,
        circle: struct { radius: f32 },
        cone: struct { angle: f32, radius: f32 },
        rectangle: struct { size: Vec2 },
    };

    pub const Particle = struct {
        position: Vec2,
        velocity: Vec2,
        rotation: f32,
        angular_velocity: f32,
        size: f32,
        color: Color,
        lifetime: f32,
        max_lifetime: f32,
        alive: bool = false,
    };

    pub fn update(self: *ParticleEmitter, delta: f32) void {
        if (!self.playing) return;

        self.elapsed += delta;

        // パーティクルの更新
        for (self.particles[0..self.active_count]) |*p| {
            if (!p.alive) continue;

            p.lifetime -= delta;
            if (p.lifetime <= 0) {
                p.alive = false;
                continue;
            }

            // 物理更新
            p.velocity = p.velocity.add(self.gravity.scale(delta));
            p.position = p.position.add(p.velocity.scale(delta));
            p.rotation += p.angular_velocity * delta;

            // ライフタイムに応じた変化
            const t = 1.0 - p.lifetime / p.max_lifetime;
            if (self.size_over_lifetime) |curve| {
                p.size = curve.evaluate(t);
            }
            if (self.color_over_lifetime) |gradient| {
                p.color = gradient.evaluate(t);
            }
        }

        // 新規パーティクル発生
        if (self.duration < 0 or self.elapsed < self.duration) {
            self.emit_timer += delta;
            const emit_interval = 1.0 / self.emission_rate;

            while (self.emit_timer >= emit_interval) {
                self.emit_timer -= emit_interval;
                self.emitParticle();
            }
        }

        // 死んだパーティクルを圧縮
        self.compactParticles();
    }

    fn emitParticle(self: *ParticleEmitter) void {
        if (self.active_count >= self.max_particles) return;

        var p = &self.particles[self.active_count];
        p.alive = true;
        p.lifetime = self.start_lifetime.random();
        p.max_lifetime = p.lifetime;
        p.size = self.start_size.random();
        p.color = self.start_color.random();
        p.rotation = self.start_rotation.random();
        p.angular_velocity = 0;

        // 形状に基づいて位置と方向を決定
        switch (self.shape) {
            .point => {
                p.position = Vec2.zero();
                p.velocity = Vec2.fromAngle(random.float() * 2 * std.math.pi).scale(self.start_speed.random());
            },
            .cone => |cone| {
                const angle = (random.float() - 0.5) * std.math.degreesToRadians(cone.angle);
                p.position = Vec2.zero();
                p.velocity = Vec2.fromAngle(angle - std.math.pi / 2).scale(self.start_speed.random());
            },
            // ... 他の形状
        }

        self.active_count += 1;
    }

    pub fn render(self: *ParticleEmitter, batch: *SpriteBatch, transform: Mat3) void {
        for (self.particles[0..self.active_count]) |*p| {
            if (!p.alive) continue;

            const world_pos = transform.transformPoint(p.position);
            batch.drawTextureEx(
                self.texture,
                world_pos,
                p.rotation,
                Vec2{ .x = p.size, .y = p.size },
                p.color,
            );
        }
    }
};
```

---

## 5. 物理エンジン

### 5.1 物理ワールド

```zig
// core/src/game/physics/world.zig

/// 2D物理ワールド
pub const PhysicsWorld2D = struct {
    gravity: Vec2 = Vec2{ .x = 0, .y = 9.81 * 100 },  // ピクセル単位
    bodies: std.ArrayList(*RigidBody),
    constraints: std.ArrayList(*Constraint),

    // ブロードフェーズ
    broad_phase: BroadPhase,

    // ソルバー設定
    velocity_iterations: u32 = 8,
    position_iterations: u32 = 3,

    // コールバック
    on_collision_begin: ?*const fn (*Collision) void = null,
    on_collision_end: ?*const fn (*Collision) void = null,

    const Self = @This();

    pub fn step(self: *Self, delta: f32) void {
        // 1. 力の適用
        for (self.bodies.items) |body| {
            if (body.body_type != .dynamic) continue;

            // 重力
            body.applyForce(self.gravity.scale(body.mass * body.gravity_scale));
        }

        // 2. 速度積分
        for (self.bodies.items) |body| {
            if (body.body_type == .static) continue;

            body.velocity = body.velocity.add(body.force.scale(delta / body.mass));
            body.angular_velocity += body.torque * delta / body.inertia;

            // ダンピング
            body.velocity = body.velocity.scale(1.0 - body.linear_damping * delta);
            body.angular_velocity *= 1.0 - body.angular_damping * delta;

            body.force = Vec2.zero();
            body.torque = 0;
        }

        // 3. ブロードフェーズ (衝突候補のペアを検出)
        self.broad_phase.update(self.bodies.items);
        const pairs = self.broad_phase.getPotentialPairs();

        // 4. ナローフェーズ (正確な衝突検出)
        var contacts = std.ArrayList(Contact).init(self.allocator);
        for (pairs) |pair| {
            if (self.detectCollision(pair.a, pair.b)) |contact| {
                contacts.append(contact) catch continue;
            }
        }

        // 5. 制約ソルバー
        for (0..self.velocity_iterations) |_| {
            // コンストレイントの速度ソルブ
            for (self.constraints.items) |constraint| {
                constraint.solveVelocity(delta);
            }

            // 接触の速度ソルブ
            for (contacts.items) |*contact| {
                self.solveContactVelocity(contact, delta);
            }
        }

        // 6. 位置積分
        for (self.bodies.items) |body| {
            if (body.body_type == .static) continue;

            body.position = body.position.add(body.velocity.scale(delta));
            body.rotation += body.angular_velocity * delta;
        }

        // 7. 位置ソルバー
        for (0..self.position_iterations) |_| {
            for (contacts.items) |*contact| {
                self.solveContactPosition(contact);
            }
        }

        // 8. コールバック
        for (contacts.items) |*contact| {
            if (contact.is_new and self.on_collision_begin != null) {
                self.on_collision_begin.?(contact);
            }
        }
    }

    fn detectCollision(self: *Self, a: *RigidBody, b: *RigidBody) ?Contact {
        const shape_a = a.shape;
        const shape_b = b.shape;

        return switch (shape_a) {
            .circle => |circle_a| switch (shape_b) {
                .circle => |circle_b| circleVsCircle(a, circle_a, b, circle_b),
                .box => |box_b| circleVsBox(a, circle_a, b, box_b),
                .polygon => |poly_b| circleVsPolygon(a, circle_a, b, poly_b),
            },
            .box => |box_a| switch (shape_b) {
                .circle => |circle_b| circleVsBox(b, circle_b, a, box_a),
                .box => |box_b| boxVsBox(a, box_a, b, box_b),
                .polygon => |poly_b| boxVsPolygon(a, box_a, b, poly_b),
            },
            .polygon => |poly_a| switch (shape_b) {
                .circle => |circle_b| circleVsPolygon(b, circle_b, a, poly_a),
                .box => |box_b| boxVsPolygon(b, box_b, a, poly_a),
                .polygon => |poly_b| polygonVsPolygon(a, poly_a, b, poly_b),
            },
        };
    }

    fn solveContactVelocity(self: *Self, contact: *Contact, delta: f32) void {
        const a = contact.body_a;
        const b = contact.body_b;

        // 相対速度
        const ra = contact.point.sub(a.position);
        const rb = contact.point.sub(b.position);
        const relative_velocity = b.velocity.add(Vec2.perpendicular(rb).scale(b.angular_velocity))
            .sub(a.velocity.add(Vec2.perpendicular(ra).scale(a.angular_velocity)));

        const contact_velocity = relative_velocity.dot(contact.normal);

        // 分離中なら何もしない
        if (contact_velocity > 0) return;

        // 反発係数
        const restitution = @min(a.restitution, b.restitution);

        // インパルス計算
        const ra_cross_n = ra.cross(contact.normal);
        const rb_cross_n = rb.cross(contact.normal);
        const inv_mass_sum = a.inv_mass + b.inv_mass +
            ra_cross_n * ra_cross_n * a.inv_inertia +
            rb_cross_n * rb_cross_n * b.inv_inertia;

        var j = -(1.0 + restitution) * contact_velocity;
        j /= inv_mass_sum;

        // インパルス適用
        const impulse = contact.normal.scale(j);
        a.velocity = a.velocity.sub(impulse.scale(a.inv_mass));
        a.angular_velocity -= ra.cross(impulse) * a.inv_inertia;
        b.velocity = b.velocity.add(impulse.scale(b.inv_mass));
        b.angular_velocity += rb.cross(impulse) * b.inv_inertia;

        // 摩擦インパルス
        self.solveFriction(contact, a, b, ra, rb, j);
    }
};
```

### 5.2 衝突形状

```zig
// core/src/game/physics/shapes.zig

/// 円形状
pub const CircleShape = struct {
    radius: f32,

    pub fn computeAABB(self: CircleShape, position: Vec2) AABB {
        return AABB{
            .min = position.sub(Vec2{ .x = self.radius, .y = self.radius }),
            .max = position.add(Vec2{ .x = self.radius, .y = self.radius }),
        };
    }

    pub fn computeMass(self: CircleShape, density: f32) struct { mass: f32, inertia: f32 } {
        const mass = std.math.pi * self.radius * self.radius * density;
        const inertia = 0.5 * mass * self.radius * self.radius;
        return .{ .mass = mass, .inertia = inertia };
    }
};

/// ポリゴン形状
pub const PolygonShape = struct {
    vertices: []Vec2,  // ローカル座標、反時計回り
    normals: []Vec2,

    pub fn createBox(half_width: f32, half_height: f32) PolygonShape {
        return PolygonShape{
            .vertices = &[_]Vec2{
                Vec2{ .x = -half_width, .y = -half_height },
                Vec2{ .x = half_width, .y = -half_height },
                Vec2{ .x = half_width, .y = half_height },
                Vec2{ .x = -half_width, .y = half_height },
            },
            .normals = &[_]Vec2{
                Vec2{ .x = 0, .y = -1 },
                Vec2{ .x = 1, .y = 0 },
                Vec2{ .x = 0, .y = 1 },
                Vec2{ .x = -1, .y = 0 },
            },
        };
    }

    pub fn computeAABB(self: PolygonShape, position: Vec2, rotation: f32) AABB {
        var min = Vec2{ .x = std.math.floatMax(f32), .y = std.math.floatMax(f32) };
        var max = Vec2{ .x = -std.math.floatMax(f32), .y = -std.math.floatMax(f32) };

        const rot_mat = Mat2.rotation(rotation);

        for (self.vertices) |v| {
            const world_v = rot_mat.transform(v).add(position);
            min = Vec2.min(min, world_v);
            max = Vec2.max(max, world_v);
        }

        return AABB{ .min = min, .max = max };
    }
};

/// SAT (Separating Axis Theorem) による衝突検出
pub fn polygonVsPolygon(a: *RigidBody, shape_a: PolygonShape, b: *RigidBody, shape_b: PolygonShape) ?Contact {
    // A の軸でテスト
    var min_penetration = std.math.floatMax(f32);
    var best_axis: Vec2 = undefined;
    var best_index: usize = 0;

    for (shape_a.normals, 0..) |normal, i| {
        const world_normal = a.getWorldVector(normal);
        const penetration = findAxisPenetration(a, shape_a, b, shape_b, world_normal);

        if (penetration < 0) return null;  // 分離軸発見

        if (penetration < min_penetration) {
            min_penetration = penetration;
            best_axis = world_normal;
            best_index = i;
        }
    }

    // B の軸でテスト
    for (shape_b.normals) |normal| {
        const world_normal = b.getWorldVector(normal);
        const penetration = findAxisPenetration(a, shape_a, b, shape_b, world_normal);

        if (penetration < 0) return null;

        if (penetration < min_penetration) {
            min_penetration = penetration;
            best_axis = world_normal;
        }
    }

    // 接触点を計算
    const contact_point = findContactPoint(a, shape_a, b, shape_b, best_axis);

    return Contact{
        .body_a = a,
        .body_b = b,
        .point = contact_point,
        .normal = best_axis,
        .penetration = min_penetration,
    };
}
```

### 5.3 コンストレイント

```zig
// core/src/game/physics/constraints.zig

/// 距離コンストレイント
pub const DistanceConstraint = struct {
    body_a: *RigidBody,
    body_b: *RigidBody,
    anchor_a: Vec2,  // ローカル座標
    anchor_b: Vec2,
    target_distance: f32,
    stiffness: f32 = 1.0,
    damping: f32 = 0.0,

    pub fn solveVelocity(self: *DistanceConstraint, delta: f32) void {
        const world_a = self.body_a.getWorldPoint(self.anchor_a);
        const world_b = self.body_b.getWorldPoint(self.anchor_b);

        const axis = world_b.sub(world_a);
        const current_distance = axis.length();
        if (current_distance < 0.0001) return;

        const normal = axis.normalize();

        // 現在の相対速度
        const relative_velocity = self.body_b.getVelocityAtPoint(world_b)
            .sub(self.body_a.getVelocityAtPoint(world_a));
        const velocity_along_axis = relative_velocity.dot(normal);

        // バネ・ダンパー力
        const position_error = current_distance - self.target_distance;
        const impulse_magnitude = -(self.stiffness * position_error + self.damping * velocity_along_axis);

        const impulse = normal.scale(impulse_magnitude * delta);

        self.body_a.applyImpulse(impulse.negate(), world_a);
        self.body_b.applyImpulse(impulse, world_b);
    }
};

/// 回転コンストレイント (ヒンジ)
pub const RevoluteConstraint = struct {
    body_a: *RigidBody,
    body_b: *RigidBody,
    anchor: Vec2,  // ワールド座標
    enable_limit: bool = false,
    lower_angle: f32 = 0,
    upper_angle: f32 = 0,
    enable_motor: bool = false,
    motor_speed: f32 = 0,
    max_motor_torque: f32 = 0,
};

/// マウスコンストレイント (ドラッグ用)
pub const MouseConstraint = struct {
    body: *RigidBody,
    target: Vec2,
    anchor: Vec2,  // ボディ上のローカル座標
    stiffness: f32 = 0.9,
    damping: f32 = 0.3,

    pub fn setTarget(self: *MouseConstraint, world_pos: Vec2) void {
        self.target = world_pos;
    }

    pub fn solveVelocity(self: *MouseConstraint, delta: f32) void {
        const world_anchor = self.body.getWorldPoint(self.anchor);
        const delta_pos = self.target.sub(world_anchor);

        // PD制御
        const velocity = self.body.getVelocityAtPoint(world_anchor);
        const impulse = delta_pos.scale(self.stiffness / delta).sub(velocity.scale(self.damping));

        self.body.applyImpulse(impulse.scale(self.body.mass), world_anchor);
    }
};
```

---

## 6. オーディオエンジン

### 6.1 オーディオエンジンコア

```zig
// core/src/game/audio/engine.zig

/// クロスプラットフォームオーディオエンジン
pub const AudioEngine = struct {
    context: *AudioContext,
    master_volume: f32 = 1.0,
    sources: std.ArrayList(*AudioSource),
    listener: Listener,

    // オーディオグループ
    groups: std.StringHashMap(*AudioGroup),

    // バックエンド
    backend: AudioBackend,

    const Self = @This();

    pub fn init() !*Self {
        const engine = try allocator.create(Self);

        engine.backend = try AudioBackend.init();
        engine.context = try engine.backend.createContext(.{
            .sample_rate = 48000,
            .channels = 2,
            .buffer_size = 1024,
        });

        // デフォルトグループ
        engine.groups.put("master", try AudioGroup.init("master"));
        engine.groups.put("sfx", try AudioGroup.init("sfx"));
        engine.groups.put("music", try AudioGroup.init("music"));
        engine.groups.put("voice", try AudioGroup.init("voice"));

        return engine;
    }

    /// サウンドを再生
    pub fn play(self: *Self, clip: *AudioClip, options: PlayOptions) *AudioSource {
        const source = self.acquireSource();

        source.clip = clip;
        source.volume = options.volume;
        source.pitch = options.pitch;
        source.loop = options.loop;
        source.spatial = options.spatial;
        source.position = options.position;
        source.group = self.groups.get(options.group) orelse self.groups.get("sfx").?;

        source.state = .playing;
        self.backend.playSource(source);

        return source;
    }

    /// BGMを再生 (フェードイン付き)
    pub fn playMusic(self: *Self, clip: *AudioClip, fade_duration: f32) *AudioSource {
        // 現在のBGMをフェードアウト
        if (self.current_music) |current| {
            self.fadeOut(current, fade_duration);
        }

        const source = self.play(clip, .{
            .group = "music",
            .loop = true,
            .volume = 0.0,
        });

        self.fadeIn(source, self.groups.get("music").?.volume, fade_duration);
        self.current_music = source;

        return source;
    }

    /// クロスフェード
    pub fn crossfade(self: *Self, new_clip: *AudioClip, duration: f32) void {
        if (self.current_music) |current| {
            self.fadeOut(current, duration);
        }

        const source = self.play(new_clip, .{
            .group = "music",
            .loop = true,
            .volume = 0.0,
        });

        self.fadeIn(source, self.groups.get("music").?.volume, duration);
        self.current_music = source;
    }

    /// フェードイン
    pub fn fadeIn(self: *Self, source: *AudioSource, target_volume: f32, duration: f32) void {
        source.fade = .{
            .start_volume = source.volume,
            .end_volume = target_volume,
            .duration = duration,
            .elapsed = 0,
        };
    }

    /// フェードアウト
    pub fn fadeOut(self: *Self, source: *AudioSource, duration: f32) void {
        source.fade = .{
            .start_volume = source.volume,
            .end_volume = 0,
            .duration = duration,
            .elapsed = 0,
            .stop_on_complete = true,
        };
    }

    /// 3D空間オーディオ更新
    pub fn update(self: *Self, delta: f32) void {
        for (self.sources.items) |source| {
            if (source.state != .playing) continue;

            // フェード処理
            if (source.fade) |*fade| {
                fade.elapsed += delta;
                const t = @min(fade.elapsed / fade.duration, 1.0);
                source.volume = std.math.lerp(fade.start_volume, fade.end_volume, t);

                if (t >= 1.0) {
                    if (fade.stop_on_complete) {
                        source.stop();
                    }
                    source.fade = null;
                }
            }

            // 空間オーディオ
            if (source.spatial) {
                self.updateSpatialAudio(source);
            }
        }
    }

    fn updateSpatialAudio(self: *Self, source: *AudioSource) void {
        const to_listener = self.listener.position.sub(source.position);
        const distance = to_listener.length();

        // 距離減衰
        const attenuation = switch (source.rolloff) {
            .linear => 1.0 - std.math.clamp((distance - source.min_distance) / (source.max_distance - source.min_distance), 0, 1),
            .logarithmic => source.min_distance / (source.min_distance + source.rolloff_factor * (distance - source.min_distance)),
        };

        // パン (ステレオ)
        const direction = to_listener.normalize();
        const right = self.listener.getRight();
        const pan = direction.dot(right);

        self.backend.setSourceAttenuation(source, attenuation);
        self.backend.setSourcePan(source, pan);
    }

    pub const PlayOptions = struct {
        volume: f32 = 1.0,
        pitch: f32 = 1.0,
        loop: bool = false,
        spatial: bool = false,
        position: Vec2 = Vec2.zero(),
        group: []const u8 = "sfx",
    };
};

/// オーディオグループ (ミキサーチャンネル)
pub const AudioGroup = struct {
    name: []const u8,
    volume: f32 = 1.0,
    muted: bool = false,
    sources: std.ArrayList(*AudioSource),

    pub fn setVolume(self: *AudioGroup, volume: f32) void {
        self.volume = volume;
        for (self.sources.items) |source| {
            source.updateVolume();
        }
    }

    pub fn setMuted(self: *AudioGroup, muted: bool) void {
        self.muted = muted;
        for (self.sources.items) |source| {
            source.updateVolume();
        }
    }
};
```

### 6.2 オーディオクリップ

```zig
// core/src/game/audio/clip.zig

/// オーディオクリップ
pub const AudioClip = struct {
    data: AudioData,
    sample_rate: u32,
    channels: u8,
    duration: f32,

    // ストリーミング
    streaming: bool = false,
    stream_buffer_size: usize = 4096,

    pub const AudioData = union(enum) {
        pcm: []f32,                // メモリ上のPCMデータ
        compressed: []u8,          // デコード前の圧縮データ
        streaming: StreamHandle,   // ストリーミングソース
    };

    /// ファイルから読み込み
    pub fn load(path: []const u8, options: LoadOptions) !*AudioClip {
        const extension = std.fs.path.extension(path);

        return switch (extension) {
            ".wav" => loadWav(path),
            ".ogg" => loadOgg(path, options.streaming),
            ".mp3" => loadMp3(path, options.streaming),
            ".flac" => loadFlac(path, options.streaming),
            else => error.UnsupportedFormat,
        };
    }

    fn loadWav(path: []const u8) !*AudioClip {
        const file = try std.fs.cwd().openFile(path, .{});
        defer file.close();

        // WAV ヘッダー解析
        var header: WavHeader = undefined;
        _ = try file.read(std.mem.asBytes(&header));

        if (!std.mem.eql(u8, &header.riff, "RIFF") or
            !std.mem.eql(u8, &header.wave, "WAVE")) {
            return error.InvalidWavFile;
        }

        // PCM データ読み込み
        const clip = try allocator.create(AudioClip);
        clip.sample_rate = header.sample_rate;
        clip.channels = @intCast(u8, header.num_channels);

        const samples = try allocator.alloc(f32, header.subchunk2_size / @sizeOf(i16));
        clip.data = .{ .pcm = samples };

        // 16-bit PCM → float 変換
        var i16_buffer = try allocator.alloc(i16, samples.len);
        defer allocator.free(i16_buffer);
        _ = try file.read(std.mem.sliceAsBytes(i16_buffer));

        for (i16_buffer, 0..) |sample, i| {
            samples[i] = @intToFloat(f32, sample) / 32768.0;
        }

        clip.duration = @intToFloat(f32, samples.len) / @intToFloat(f32, clip.sample_rate * clip.channels);

        return clip;
    }

    pub const LoadOptions = struct {
        streaming: bool = false,
        preload: bool = true,
    };
};
```

### 6.3 プラットフォームバックエンド

```zig
// core/src/game/audio/backends/core_audio.zig (macOS/iOS)

pub const CoreAudioBackend = struct {
    audio_unit: AudioUnit,
    sample_rate: f32,

    pub fn init() !CoreAudioBackend {
        var desc = AudioComponentDescription{
            .componentType = kAudioUnitType_Output,
            .componentSubType = kAudioUnitSubType_DefaultOutput,
            .componentManufacturer = kAudioUnitManufacturer_Apple,
        };

        const component = AudioComponentFindNext(null, &desc);
        var audio_unit: AudioUnit = undefined;
        try checkOSStatus(AudioComponentInstanceNew(component, &audio_unit));

        // フォーマット設定
        var format = AudioStreamBasicDescription{
            .mSampleRate = 48000,
            .mFormatID = kAudioFormatLinearPCM,
            .mFormatFlags = kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked,
            .mBytesPerPacket = 8,
            .mFramesPerPacket = 1,
            .mBytesPerFrame = 8,
            .mChannelsPerFrame = 2,
            .mBitsPerChannel = 32,
        };

        try checkOSStatus(AudioUnitSetProperty(
            audio_unit,
            kAudioUnitProperty_StreamFormat,
            kAudioUnitScope_Input,
            0,
            &format,
            @sizeOf(@TypeOf(format)),
        ));

        // レンダーコールバック設定
        var callback = AURenderCallbackStruct{
            .inputProc = renderCallback,
            .inputProcRefCon = @ptrCast(*anyopaque, self),
        };

        try checkOSStatus(AudioUnitSetProperty(
            audio_unit,
            kAudioUnitProperty_SetRenderCallback,
            kAudioUnitScope_Input,
            0,
            &callback,
            @sizeOf(@TypeOf(callback)),
        ));

        try checkOSStatus(AudioUnitInitialize(audio_unit));
        try checkOSStatus(AudioOutputUnitStart(audio_unit));

        return .{ .audio_unit = audio_unit, .sample_rate = 48000 };
    }

    fn renderCallback(
        in_ref_con: *anyopaque,
        _: *AudioUnitRenderActionFlags,
        _: *const AudioTimeStamp,
        _: u32,
        in_number_frames: u32,
        io_data: *AudioBufferList,
    ) callconv(.C) OSStatus {
        const self = @ptrCast(*CoreAudioBackend, @alignCast(@alignOf(CoreAudioBackend), in_ref_con));
        const buffer = @ptrCast([*]f32, @alignCast(@alignOf(f32), io_data.mBuffers[0].mData));
        const frame_count = in_number_frames;

        // オーディオミキシング
        self.mix(buffer[0 .. frame_count * 2]);

        return noErr;
    }
};
```

---

## 7. シーン管理

### 7.1 シーン

```zig
// core/src/game/scene/scene.zig

/// ゲームシーン
pub const Scene = struct {
    name: []const u8,
    world: *World,
    layers: std.ArrayList(*Layer),
    camera: *Camera2D,

    // シーン状態
    state: State = .inactive,
    elapsed: f32 = 0,

    // コールバック
    on_enter: ?*const fn (*Scene) void = null,
    on_exit: ?*const fn (*Scene) void = null,
    on_pause: ?*const fn (*Scene) void = null,
    on_resume: ?*const fn (*Scene) void = null,

    pub const State = enum { inactive, entering, active, exiting, paused };

    pub fn update(self: *Scene, delta: f32) void {
        if (self.state != .active) return;

        self.elapsed += delta;
        self.world.update(delta);
    }

    pub fn render(self: *Scene, renderer: *Renderer2D) void {
        renderer.beginScene(self.camera);

        for (self.layers.items) |layer| {
            if (layer.visible) {
                layer.render(renderer);
            }
        }

        renderer.endScene();
    }

    /// レイヤーを追加
    pub fn addLayer(self: *Scene, name: []const u8) *Layer {
        const layer = Layer.init(name);
        self.layers.append(layer);
        return layer;
    }

    /// エンティティを追加
    pub fn spawn(self: *Scene) EntityBuilder {
        return self.world.spawn();
    }
};

/// レイヤー
pub const Layer = struct {
    name: []const u8,
    entities: std.ArrayList(Entity),
    z_order: i32 = 0,
    visible: bool = true,
    parallax: Vec2 = Vec2.one(),

    pub fn render(self: *Layer, renderer: *Renderer2D) void {
        // パララックス効果
        const offset = renderer.camera.position.mul(Vec2.one().sub(self.parallax));
        renderer.pushOffset(offset);

        for (self.entities.items) |entity| {
            // エンティティのレンダリング
        }

        renderer.popOffset();
    }
};
```

### 7.2 シーンマネージャー

```zig
// core/src/game/scene/manager.zig

/// シーンマネージャー
pub const SceneManager = struct {
    scenes: std.StringHashMap(*Scene),
    active_scenes: std.ArrayList(*Scene),
    transition: ?Transition = null,

    /// シーンを登録
    pub fn register(self: *SceneManager, name: []const u8, scene: *Scene) void {
        scene.name = name;
        self.scenes.put(name, scene);
    }

    /// シーンを切り替え
    pub fn switchTo(self: *SceneManager, name: []const u8, transition: ?TransitionType) void {
        const next_scene = self.scenes.get(name) orelse return;

        if (transition) |t| {
            self.transition = Transition{
                .type = t,
                .from = self.getCurrentScene(),
                .to = next_scene,
                .progress = 0,
            };
        } else {
            self.immediateSwitch(next_scene);
        }
    }

    /// シーンをプッシュ (オーバーレイ)
    pub fn push(self: *SceneManager, name: []const u8) void {
        const scene = self.scenes.get(name) orelse return;

        if (self.getCurrentScene()) |current| {
            current.state = .paused;
            if (current.on_pause) |callback| {
                callback(current);
            }
        }

        scene.state = .active;
        self.active_scenes.append(scene);

        if (scene.on_enter) |callback| {
            callback(scene);
        }
    }

    /// シーンをポップ
    pub fn pop(self: *SceneManager) void {
        if (self.active_scenes.popOrNull()) |scene| {
            scene.state = .inactive;
            if (scene.on_exit) |callback| {
                callback(scene);
            }
        }

        if (self.getCurrentScene()) |current| {
            current.state = .active;
            if (current.on_resume) |callback| {
                callback(current);
            }
        }
    }

    pub fn update(self: *SceneManager, delta: f32) void {
        // トランジション処理
        if (self.transition) |*t| {
            t.progress += delta / t.type.duration();

            if (t.progress >= 1.0) {
                self.immediateSwitch(t.to);
                self.transition = null;
            }
        }

        // アクティブシーンの更新
        for (self.active_scenes.items) |scene| {
            scene.update(delta);
        }
    }

    pub fn render(self: *SceneManager, renderer: *Renderer2D) void {
        // シーンをレンダリング
        for (self.active_scenes.items) |scene| {
            scene.render(renderer);
        }

        // トランジション効果
        if (self.transition) |*t| {
            t.render(renderer);
        }
    }
};

/// トランジション
pub const Transition = struct {
    type: TransitionType,
    from: ?*Scene,
    to: *Scene,
    progress: f32,

    pub fn render(self: *Transition, renderer: *Renderer2D) void {
        switch (self.type) {
            .fade => {
                const alpha = if (self.progress < 0.5)
                    self.progress * 2
                else
                    1.0 - (self.progress - 0.5) * 2;
                renderer.drawRect(Rect.fullScreen(), Color.black().withAlpha(alpha));
            },
            .slide_left => {
                const offset = (1.0 - self.progress) * renderer.screen_width;
                if (self.from) |from| {
                    renderer.pushOffset(Vec2{ .x = offset, .y = 0 });
                    from.render(renderer);
                    renderer.popOffset();
                }
                renderer.pushOffset(Vec2{ .x = offset - renderer.screen_width, .y = 0 });
                self.to.render(renderer);
                renderer.popOffset();
            },
            // ... 他のトランジション
        }
    }
};

pub const TransitionType = enum {
    fade,
    slide_left,
    slide_right,
    slide_up,
    slide_down,
    zoom,
    wipe,

    pub fn duration(self: TransitionType) f32 {
        return switch (self) {
            .fade => 0.5,
            .slide_left, .slide_right => 0.3,
            .slide_up, .slide_down => 0.3,
            .zoom => 0.4,
            .wipe => 0.5,
        };
    }
};
```

---

## 8. リソース管理

### 8.1 アセットローダー

```zig
// core/src/game/assets/loader.zig

/// アセットローダー
pub const AssetLoader = struct {
    textures: std.StringHashMap(*Texture),
    atlases: std.StringHashMap(*TextureAtlas),
    audio_clips: std.StringHashMap(*AudioClip),
    fonts: std.StringHashMap(*Font),
    tilemaps: std.StringHashMap(*Tilemap),
    prefabs: std.StringHashMap(*Prefab),

    // 非同期ロード
    pending: std.ArrayList(LoadTask),
    thread_pool: *ThreadPool,

    /// アセットマニフェストから読み込み
    pub fn loadManifest(self: *AssetLoader, path: []const u8) !void {
        const data = try std.fs.cwd().readFileAlloc(allocator, path, 1024 * 1024);
        defer allocator.free(data);

        const manifest = try std.json.parse(Manifest, data);

        for (manifest.textures) |tex| {
            try self.loadTextureAsync(tex.name, tex.path);
        }
        for (manifest.audio) |audio| {
            try self.loadAudioAsync(audio.name, audio.path);
        }
        // ... 他のアセット
    }

    /// 非同期テクスチャ読み込み
    pub fn loadTextureAsync(self: *AssetLoader, name: []const u8, path: []const u8) !void {
        const task = LoadTask{
            .type = .texture,
            .name = name,
            .path = path,
            .state = .pending,
        };
        self.pending.append(task);
        self.thread_pool.submit(loadTextureTask, &task);
    }

    /// ロード進捗
    pub fn getProgress(self: *AssetLoader) f32 {
        var completed: usize = 0;
        for (self.pending.items) |task| {
            if (task.state == .completed) completed += 1;
        }
        return @intToFloat(f32, completed) / @intToFloat(f32, self.pending.items.len);
    }

    /// テクスチャ取得
    pub fn getTexture(self: *AssetLoader, name: []const u8) ?*Texture {
        return self.textures.get(name);
    }

    /// オーディオクリップ取得
    pub fn getAudio(self: *AssetLoader, name: []const u8) ?*AudioClip {
        return self.audio_clips.get(name);
    }
};

/// テクスチャアトラス
pub const TextureAtlas = struct {
    texture: *Texture,
    regions: std.StringHashMap(TextureRegion),

    /// TexturePacker JSON フォーマット
    pub fn loadFromJSON(path: []const u8) !*TextureAtlas {
        const data = try std.fs.cwd().readFileAlloc(allocator, path, 1024 * 1024);
        defer allocator.free(data);

        const json = try std.json.parse(AtlasJSON, data);

        const atlas = try allocator.create(TextureAtlas);
        atlas.texture = try Texture.load(json.meta.image);

        for (json.frames) |frame| {
            atlas.regions.put(frame.filename, TextureRegion{
                .x = frame.frame.x,
                .y = frame.frame.y,
                .width = frame.frame.w,
                .height = frame.frame.h,
                .u0 = @intToFloat(f32, frame.frame.x) / @intToFloat(f32, json.meta.size.w),
                .v0 = @intToFloat(f32, frame.frame.y) / @intToFloat(f32, json.meta.size.h),
                .u1 = @intToFloat(f32, frame.frame.x + frame.frame.w) / @intToFloat(f32, json.meta.size.w),
                .v1 = @intToFloat(f32, frame.frame.y + frame.frame.h) / @intToFloat(f32, json.meta.size.h),
            });
        }

        return atlas;
    }

    pub fn getRegion(self: *TextureAtlas, name: []const u8) ?TextureRegion {
        return self.regions.get(name);
    }
};
```

### 8.2 プリファブ

```zig
// core/src/game/assets/prefab.zig

/// プリファブ (エンティティテンプレート)
pub const Prefab = struct {
    name: []const u8,
    components: std.ArrayList(ComponentData),

    pub const ComponentData = struct {
        type_id: std.builtin.TypeId,
        data: []const u8,  // シリアライズされたコンポーネント
    };

    /// プリファブからエンティティを生成
    pub fn instantiate(self: *Prefab, world: *World) Entity {
        const entity = world.spawn().build();

        for (self.components.items) |comp_data| {
            // コンポーネントをデシリアライズして追加
            world.insertRaw(entity, comp_data.type_id, comp_data.data);
        }

        return entity;
    }

    /// ファイルから読み込み
    pub fn load(path: []const u8) !*Prefab {
        // YAML または JSON からパース
    }

    /// ファイルに保存
    pub fn save(self: *Prefab, path: []const u8) !void {
        // YAML または JSON にシリアライズ
    }
};
```

---

## 9. TypeScript API

```typescript
// bindings/typescript/src/game/index.ts

// ECS
export class World {
  spawn(): EntityBuilder;
  despawn(entity: Entity): void;
  get<T extends Component>(entity: Entity, component: ComponentClass<T>): T | null;
  insert<T extends Component>(entity: Entity, component: T): void;
  query<T extends Component[]>(...components: ComponentClass<T[number]>[]): Query<T>;
  addSystem(stage: Stage, system: System): void;
  update(delta: number): void;
}

export class EntityBuilder {
  with<T extends Component>(component: T): this;
  build(): Entity;
}

// コンポーネント
export class Transform2D extends Component {
  position: Vec2;
  rotation: number;
  scale: Vec2;
  translate(delta: Vec2): void;
  rotate(angle: number): void;
}

export class Sprite extends Component {
  texture: Texture;
  region?: TextureRegion;
  color: Color;
  anchor: Vec2;
  flipX: boolean;
  flipY: boolean;
  zIndex: number;
  visible: boolean;
}

export class RigidBody2D extends Component {
  bodyType: BodyType;
  velocity: Vec2;
  angularVelocity: number;
  mass: number;
  applyForce(force: Vec2): void;
  applyImpulse(impulse: Vec2, point?: Vec2): void;
}

export class Collider2D extends Component {
  shape: Shape2D;
  isSensor: boolean;
  friction: number;
  restitution: number;
  collisionLayer: number;
  collisionMask: number;
}

// 物理
export class PhysicsWorld2D {
  gravity: Vec2;
  step(delta: number): void;
  raycast(origin: Vec2, direction: Vec2, maxDistance: number): RaycastHit | null;
  overlapCircle(center: Vec2, radius: number): Entity[];
  addConstraint(constraint: Constraint): void;
}

// オーディオ
export class AudioEngine {
  masterVolume: number;
  play(clip: AudioClip, options?: PlayOptions): AudioSource;
  playMusic(clip: AudioClip, fadeIn?: number): AudioSource;
  crossfade(clip: AudioClip, duration?: number): void;
  setGroupVolume(group: string, volume: number): void;
  setGroupMuted(group: string, muted: boolean): void;
}

export class AudioClip {
  static load(url: string, options?: LoadOptions): Promise<AudioClip>;
  readonly duration: number;
}

export class AudioSource {
  volume: number;
  pitch: number;
  loop: boolean;
  readonly state: AudioState;
  play(): void;
  pause(): void;
  stop(): void;
  fadeIn(duration: number): void;
  fadeOut(duration: number): void;
}

// シーン
export class Scene {
  readonly world: World;
  readonly camera: Camera2D;
  addLayer(name: string): Layer;
  spawn(): EntityBuilder;

  onEnter?: () => void;
  onExit?: () => void;
  onPause?: () => void;
  onResume?: () => void;
}

export class SceneManager {
  register(name: string, scene: Scene): void;
  switchTo(name: string, transition?: TransitionType): void;
  push(name: string): void;
  pop(): void;
}

// アセット
export class AssetLoader {
  loadManifest(url: string): Promise<void>;
  loadTexture(name: string, url: string): Promise<Texture>;
  loadAtlas(name: string, url: string): Promise<TextureAtlas>;
  loadAudio(name: string, url: string): Promise<AudioClip>;
  getTexture(name: string): Texture | null;
  getAtlas(name: string): TextureAtlas | null;
  getAudio(name: string): AudioClip | null;
  readonly progress: number;
}
```

### 9.1 使用例

```typescript
import {
  World, Scene, SceneManager, AssetLoader,
  Transform2D, Sprite, RigidBody2D, Collider2D,
  PhysicsWorld2D, AudioEngine, Camera2D,
  Vec2, Color, Shape2D, BodyType, TransitionType,
} from '@zylix/game';

// ゲームクラス
class MyGame {
  private world: World;
  private physics: PhysicsWorld2D;
  private audio: AudioEngine;
  private assets: AssetLoader;
  private scenes: SceneManager;

  async init() {
    // アセット読み込み
    this.assets = new AssetLoader();
    await this.assets.loadManifest('assets/manifest.json');

    // 物理ワールド
    this.physics = new PhysicsWorld2D();
    this.physics.gravity = new Vec2(0, 980);

    // オーディオ
    this.audio = new AudioEngine();

    // シーン
    this.scenes = new SceneManager();
    this.scenes.register('title', new TitleScene(this));
    this.scenes.register('game', new GameScene(this));
    this.scenes.switchTo('title');
  }

  update(delta: number) {
    this.scenes.update(delta);
  }

  render() {
    this.scenes.render();
  }
}

// ゲームシーン
class GameScene extends Scene {
  private player: Entity;

  onEnter() {
    // プレイヤーを生成
    this.player = this.spawn()
      .with(new Transform2D({
        position: new Vec2(100, 100),
      }))
      .with(new Sprite({
        texture: game.assets.getTexture('player'),
        anchor: new Vec2(0.5, 0.5),
      }))
      .with(new RigidBody2D({
        bodyType: BodyType.Dynamic,
        mass: 1.0,
      }))
      .with(new Collider2D({
        shape: Shape2D.box(16, 32),
      }))
      .with(new PlayerController())
      .build();

    // BGM再生
    game.audio.playMusic(game.assets.getAudio('bgm_game'), 1.0);

    // 物理コールバック
    game.physics.onCollisionBegin = (collision) => {
      if (collision.hasTag('coin')) {
        game.audio.play(game.assets.getAudio('sfx_coin'));
        this.world.despawn(collision.other);
      }
    };
  }

  onExit() {
    game.audio.fadeOut(game.audio.currentMusic, 0.5);
  }
}

// プレイヤー制御システム
class PlayerController extends Component {
  speed: number = 200;
  jumpForce: number = 500;
}

function playerControlSystem(world: World) {
  const input = world.resource(Input);

  for (const [entity, transform, body, controller] of world.query(
    Transform2D, RigidBody2D, PlayerController
  )) {
    // 移動
    let moveX = 0;
    if (input.isPressed('ArrowLeft')) moveX -= 1;
    if (input.isPressed('ArrowRight')) moveX += 1;

    body.velocity.x = moveX * controller.speed;

    // ジャンプ
    if (input.isJustPressed('Space') && isGrounded(entity)) {
      body.applyImpulse(new Vec2(0, -controller.jumpForce));
      game.audio.play(game.assets.getAudio('sfx_jump'));
    }
  }
}

// ゲームループ
const game = new MyGame();
await game.init();

function gameLoop(timestamp: number) {
  const delta = (timestamp - lastTime) / 1000;
  lastTime = timestamp;

  game.update(delta);
  game.render();

  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
```

---

## 10. 実装スケジュール

| タスク | 期間 |
|--------|------|
| ECS コア (World, Entity, Component) | 2週間 |
| システムスケジューラー | 1週間 |
| 2Dスプライトバッチレンダラー | 2週間 |
| タイルマップシステム | 2週間 |
| パーティクルシステム | 2週間 |
| 物理エンジン (衝突検出) | 3週間 |
| 物理エンジン (ソルバー) | 2週間 |
| オーディオエンジン (Core Audio / AAudio / Web Audio) | 3週間 |
| オーディオストリーミング | 1週間 |
| シーン管理 & トランジション | 1週間 |
| アセットローダー | 1週間 |
| TypeScript バインディング | 2週間 |
| テスト & 最適化 | 2週間 |

---

## 11. パフォーマンス目標

| メトリクス | 目標値 |
|-----------|--------|
| スプライト描画数 | 10,000+ (60fps) |
| 物理オブジェクト数 | 500+ (60fps) |
| 同時再生オーディオソース | 32+ |
| タイルマップサイズ | 1000x1000 タイル |
| パーティクル数 | 50,000+ |
| メモリ使用量 | <100MB (モバイル) |
| バッテリー効率 | 低消費電力モード対応 |

---

## 12. 依存関係

### 必須 (前提)
- v0.14.0: グラフィックスバックエンド (Metal/Vulkan/WebGPU)
- v0.13.0: アニメーションシステム (スプライトアニメーション統合)

### オプション統合
- v0.9.0: Zylix AI (NPCの行動制御)
- v0.10.0: デバイス機能 (加速度センサー入力、バイブレーション)

---

## 13. 将来の拡張

### v0.16.0 以降で検討
- ネットワーク同期 (マルチプレイヤー)
- レベルエディター
- スクリプティング (Lua または Wasm)
- VR/AR 対応 (v0.14.0 3D との統合)
- プロファイラー & デバッグツール
