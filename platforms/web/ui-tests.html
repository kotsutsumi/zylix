<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zylix UI Component Library - Tests</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
    .test-container {
      max-width: 1000px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      color: #3b82f6;
      margin-bottom: 8px;
    }
    .summary {
      text-align: center;
      font-size: 24px;
      margin-bottom: 24px;
      padding: 16px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .summary.pass { color: #10b981; }
    .summary.fail { color: #ef4444; }
    .test-group {
      background: white;
      border-radius: 8px;
      margin-bottom: 16px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .test-group-header {
      padding: 12px 16px;
      background: #f9fafb;
      font-weight: 600;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      cursor: pointer;
    }
    .test-group-header:hover { background: #f3f4f6; }
    .test-group-body { padding: 0; }
    .test-item {
      padding: 8px 16px;
      border-bottom: 1px solid #f3f4f6;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .test-item:last-child { border-bottom: none; }
    .test-item.pass { color: #059669; }
    .test-item.fail { color: #dc2626; background: #fef2f2; }
    .test-icon { font-size: 14px; }
    .test-name { flex: 1; }
    .test-error { font-size: 12px; color: #6b7280; margin-top: 4px; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <div class="test-container">
    <h1>Zylix UI Component Library Tests</h1>
    <div id="summary" class="summary">Running tests...</div>
    <div id="results"></div>
  </div>

  <script type="module">
    // Test Framework
    let passed = 0;
    let failed = 0;
    const results = {};

    function describe(name, fn) {
      results[name] = { tests: [], passed: 0, failed: 0 };
      fn();
    }

    function test(name, fn) {
      const group = Object.keys(results).pop();
      try {
        fn();
        results[group].tests.push({ name, passed: true });
        results[group].passed++;
        passed++;
      } catch (error) {
        results[group].tests.push({ name, passed: false, error: error.message });
        results[group].failed++;
        failed++;
      }
    }

    // Helper to convert hex color to RGB for comparison
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (result) {
        return `rgb(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)})`;
      }
      return hex;
    }

    function expect(actual) {
      return {
        toBe(expected) {
          if (actual !== expected) {
            throw new Error(`Expected ${JSON.stringify(expected)} but got ${JSON.stringify(actual)}`);
          }
        },
        toEqual(expected) {
          if (JSON.stringify(actual) !== JSON.stringify(expected)) {
            throw new Error(`Expected ${JSON.stringify(expected)} but got ${JSON.stringify(actual)}`);
          }
        },
        toBeTruthy() {
          if (!actual) {
            throw new Error(`Expected truthy but got ${JSON.stringify(actual)}`);
          }
        },
        toBeFalsy() {
          if (actual) {
            throw new Error(`Expected falsy but got ${JSON.stringify(actual)}`);
          }
        },
        toContain(expected) {
          if (!actual.includes(expected)) {
            throw new Error(`Expected "${actual}" to contain "${expected}"`);
          }
        },
        toBeInstanceOf(expected) {
          if (!(actual instanceof expected)) {
            throw new Error(`Expected instance of ${expected.name}`);
          }
        },
        toBeGreaterThan(expected) {
          if (actual <= expected) {
            throw new Error(`Expected ${actual} to be greater than ${expected}`);
          }
        },
        toHaveProperty(prop) {
          if (!(prop in actual)) {
            throw new Error(`Expected object to have property "${prop}"`);
          }
        },
        toHaveAttribute(attr, value) {
          const attrValue = actual.getAttribute(attr);
          if (value !== undefined) {
            if (attrValue !== value) {
              throw new Error(`Expected attribute "${attr}" to be "${value}" but got "${attrValue}"`);
            }
          } else {
            if (attrValue === null) {
              throw new Error(`Expected element to have attribute "${attr}"`);
            }
          }
        },
        toHaveStyle(prop, value) {
          const style = actual.style[prop];
          if (style !== value) {
            throw new Error(`Expected style "${prop}" to be "${value}" but got "${style}"`);
          }
        },
        toBeNull() {
          if (actual !== null) {
            throw new Error(`Expected null but got ${JSON.stringify(actual)}`);
          }
        },
        not: {
          toBe(expected) {
            if (actual === expected) {
              throw new Error(`Expected not to be ${JSON.stringify(expected)}`);
            }
          },
          toBeNull() {
            if (actual === null) {
              throw new Error(`Expected not to be null`);
            }
          },
        },
      };
    }

    // Inline UI Library (minimal for testing)
    const defaultTheme = {
      colors: {
        primary: '#3b82f6', primaryHover: '#2563eb', primaryActive: '#1d4ed8',
        secondary: '#6b7280', secondaryHover: '#4b5563', secondaryActive: '#374151',
        success: '#10b981', successHover: '#059669',
        warning: '#f59e0b', warningHover: '#d97706',
        danger: '#ef4444', dangerHover: '#dc2626',
        info: '#06b6d4', infoHover: '#0891b2',
        background: '#ffffff', surface: '#f9fafb', surfaceHover: '#f3f4f6',
        border: '#e5e7eb', borderFocus: '#3b82f6',
        text: '#111827', textSecondary: '#4b5563', textMuted: '#9ca3af', textInverse: '#ffffff',
        overlay: 'rgba(0, 0, 0, 0.5)', shadow: 'rgba(0, 0, 0, 0.1)',
      },
      spacing: { xs: '0.25rem', sm: '0.5rem', md: '1rem', lg: '1.5rem', xl: '2rem', '2xl': '3rem', '3xl': '4rem' },
      borderRadius: { none: '0', sm: '0.25rem', md: '0.5rem', lg: '0.75rem', xl: '1rem', full: '9999px' },
      fontSize: { xs: '0.75rem', sm: '0.875rem', md: '1rem', lg: '1.125rem', xl: '1.25rem', '2xl': '1.5rem', '3xl': '2rem' },
      shadow: { sm: '0 1px 2px 0 rgba(0, 0, 0, 0.05)', md: '0 4px 6px -1px rgba(0, 0, 0, 0.1)', lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1)', xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1)' },
      transition: { fast: '150ms ease', normal: '250ms ease', slow: '350ms ease' },
      breakpoints: { sm: '640px', md: '768px', lg: '1024px', xl: '1280px' },
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    };

    let currentTheme = JSON.parse(JSON.stringify(defaultTheme));
    const themeListeners = new Set();

    function deepMerge(target, source) {
      const result = { ...target };
      for (const key of Object.keys(source)) {
        if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
          result[key] = deepMerge(target[key] || {}, source[key]);
        } else { result[key] = source[key]; }
      }
      return result;
    }

    const theme = {
      get() { return currentTheme; },
      set(partial) {
        const updates = typeof partial === 'function' ? partial(currentTheme) : partial;
        currentTheme = deepMerge(currentTheme, updates);
        themeListeners.forEach(listener => listener());
      },
      reset() { currentTheme = JSON.parse(JSON.stringify(defaultTheme)); themeListeners.forEach(listener => listener()); },
      subscribe(listener) { themeListeners.add(listener); return () => themeListeners.delete(listener); },
    };

    function createId() { return `zylix-${Math.random().toString(36).substr(2, 9)}`; }
    function mergeClasses(...classes) { return classes.filter(Boolean).join(' '); }
    function createStyleString(styles) {
      return Object.entries(styles).filter(([_, value]) => value !== undefined)
        .map(([key, value]) => `${key.replace(/([A-Z])/g, '-$1').toLowerCase()}: ${value}`).join('; ');
    }

    function getVariantColors(variant) {
      const t = theme.get();
      const variants = {
        primary: { bg: t.colors.primary, text: t.colors.textInverse, border: t.colors.primary, hover: t.colors.primaryHover },
        secondary: { bg: t.colors.secondary, text: t.colors.textInverse, border: t.colors.secondary, hover: t.colors.secondaryHover },
        success: { bg: t.colors.success, text: t.colors.textInverse, border: t.colors.success, hover: t.colors.successHover },
        warning: { bg: t.colors.warning, text: t.colors.text, border: t.colors.warning, hover: t.colors.warningHover },
        danger: { bg: t.colors.danger, text: t.colors.textInverse, border: t.colors.danger, hover: t.colors.dangerHover },
        info: { bg: t.colors.info, text: t.colors.textInverse, border: t.colors.info, hover: t.colors.infoHover },
        ghost: { bg: 'transparent', text: t.colors.text, border: 'transparent', hover: t.colors.surfaceHover },
        outline: { bg: 'transparent', text: t.colors.primary, border: t.colors.primary, hover: t.colors.surface },
      };
      return variants[variant];
    }

    function getSizeStyles(size, type) {
      const t = theme.get();
      if (type === 'button') {
        const sizes = {
          xs: { padding: `${t.spacing.xs} ${t.spacing.sm}`, fontSize: t.fontSize.xs, height: '1.75rem' },
          sm: { padding: `${t.spacing.xs} ${t.spacing.md}`, fontSize: t.fontSize.sm, height: '2rem' },
          md: { padding: `${t.spacing.sm} ${t.spacing.lg}`, fontSize: t.fontSize.md, height: '2.5rem' },
          lg: { padding: `${t.spacing.md} ${t.spacing.xl}`, fontSize: t.fontSize.lg, height: '3rem' },
          xl: { padding: `${t.spacing.lg} ${t.spacing['2xl']}`, fontSize: t.fontSize.xl, height: '3.5rem' },
        };
        return sizes[size];
      }
      if (type === 'input') {
        const sizes = {
          xs: { padding: `${t.spacing.xs} ${t.spacing.sm}`, fontSize: t.fontSize.xs, height: '1.75rem' },
          sm: { padding: `${t.spacing.xs} ${t.spacing.md}`, fontSize: t.fontSize.sm, height: '2rem' },
          md: { padding: `${t.spacing.sm} ${t.spacing.md}`, fontSize: t.fontSize.md, height: '2.5rem' },
          lg: { padding: `${t.spacing.md} ${t.spacing.lg}`, fontSize: t.fontSize.lg, height: '3rem' },
          xl: { padding: `${t.spacing.lg} ${t.spacing.xl}`, fontSize: t.fontSize.xl, height: '3.5rem' },
        };
        return sizes[size];
      }
      const sizes = { xs: { fontSize: t.fontSize.xs }, sm: { fontSize: t.fontSize.sm }, md: { fontSize: t.fontSize.md }, lg: { fontSize: t.fontSize.lg }, xl: { fontSize: t.fontSize.xl } };
      return sizes[size];
    }

    function createElement(config) {
      const { tag = 'div', className, style, attrs, children, events, ref } = config;
      const el = document.createElement(tag);
      el.className = mergeClasses('zylix-component', className);
      if (style) el.setAttribute('style', createStyleString(style));
      if (attrs) {
        for (const [key, value] of Object.entries(attrs)) {
          if (value === undefined) continue;
          if (typeof value === 'boolean') { if (value) el.setAttribute(key, ''); }
          else { el.setAttribute(key, String(value)); }
        }
      }
      if (children) {
        for (const child of children) {
          if (typeof child === 'string') el.appendChild(document.createTextNode(child));
          else if (child) el.appendChild(child);
        }
      }
      if (events) { for (const [event, handler] of Object.entries(events)) { if (handler) el.addEventListener(event, handler); } }
      if (ref) ref(el);
      return el;
    }

    // Layout Components
    function Container(props) {
      const { maxWidth = 'lg', padding, center = true, className, children } = props;
      const t = theme.get();
      const widths = { sm: t.breakpoints.sm, md: t.breakpoints.md, lg: t.breakpoints.lg, xl: t.breakpoints.xl, full: '100%' };
      return createElement({ tag: 'div', className: mergeClasses('zylix-container', className), style: { width: '100%', maxWidth: widths[maxWidth] || maxWidth, margin: center ? '0 auto' : undefined, padding: padding || t.spacing.md }, children });
    }

    function Flex(props) {
      const { direction = 'row', wrap = 'nowrap', justify = 'start', align = 'stretch', gap, className, style, children } = props;
      const t = theme.get();
      const justifyMap = { start: 'flex-start', end: 'flex-end', center: 'center', between: 'space-between', around: 'space-around', evenly: 'space-evenly' };
      const alignMap = { start: 'flex-start', end: 'flex-end', center: 'center', stretch: 'stretch', baseline: 'baseline' };
      return createElement({ tag: 'div', className: mergeClasses('zylix-flex', className), style: { display: 'flex', flexDirection: direction, flexWrap: wrap, justifyContent: justifyMap[justify], alignItems: alignMap[align], gap: gap || t.spacing.md, ...style }, children });
    }

    function Grid(props) {
      const { columns = 12, rows, gap, columnGap, rowGap, className, style, children } = props;
      const t = theme.get();
      const gridCols = typeof columns === 'number' ? `repeat(${columns}, 1fr)` : columns;
      const gridRows = rows ? (typeof rows === 'number' ? `repeat(${rows}, 1fr)` : rows) : undefined;
      return createElement({ tag: 'div', className: mergeClasses('zylix-grid', className), style: { display: 'grid', gridTemplateColumns: gridCols, gridTemplateRows: gridRows, gap: gap || t.spacing.md, columnGap, rowGap, ...style }, children });
    }

    function Stack(props) {
      const { direction = 'vertical', gap, align = 'stretch', className, children } = props;
      const t = theme.get();
      return Flex({ direction: direction === 'vertical' ? 'column' : 'row', gap: gap || t.spacing.md, align, className: mergeClasses('zylix-stack', className), children });
    }

    function Divider(props = {}) {
      const { orientation = 'horizontal', color, thickness = '1px', margin, className } = props;
      const t = theme.get();
      const isHorizontal = orientation === 'horizontal';
      return createElement({ tag: 'hr', className: mergeClasses('zylix-divider', className), style: { border: 'none', backgroundColor: color || t.colors.border, width: isHorizontal ? '100%' : thickness, height: isHorizontal ? thickness : '100%', margin: margin || (isHorizontal ? `${t.spacing.md} 0` : `0 ${t.spacing.md}`) }, attrs: { role: 'separator', 'aria-orientation': orientation } });
    }

    // Form Components
    function Button(props) {
      const { variant = 'primary', size = 'md', disabled = false, loading = false, fullWidth = false, type = 'button', onClick, className, children = [] } = props;
      const t = theme.get();
      const colors = getVariantColors(variant);
      const sizeStyles = getSizeStyles(size, 'button');
      const isOutline = variant === 'outline';
      return createElement({
        tag: 'button', className: mergeClasses('zylix-button', className),
        style: { display: 'inline-flex', alignItems: 'center', justifyContent: 'center', gap: t.spacing.sm, border: isOutline ? `2px solid ${colors.border}` : 'none', borderRadius: t.borderRadius.md, backgroundColor: colors.bg, color: colors.text, cursor: disabled || loading ? 'not-allowed' : 'pointer', opacity: disabled ? '0.5' : '1', fontWeight: '500', transition: `all ${t.transition.fast}`, width: fullWidth ? '100%' : undefined, ...sizeStyles },
        attrs: { type, disabled: disabled || loading, 'aria-disabled': disabled || loading, 'aria-busy': loading },
        children, events: onClick && !disabled && !loading ? { click: onClick } : undefined,
      });
    }

    function Input(props) {
      const { type = 'text', size = 'md', placeholder, value, defaultValue, disabled = false, error, label, helperText, onChange, className, id = createId() } = props;
      const t = theme.get();
      const sizeStyles = getSizeStyles(size, 'input');
      const hasError = !!error;
      const errorMessage = typeof error === 'string' ? error : undefined;

      const inputEl = createElement({
        tag: 'input', style: { width: '100%', border: `1px solid ${hasError ? t.colors.danger : t.colors.border}`, borderRadius: t.borderRadius.md, backgroundColor: disabled ? t.colors.surface : t.colors.background, color: t.colors.text, outline: 'none', ...sizeStyles },
        attrs: { type, id, placeholder, value, disabled, 'aria-invalid': hasError },
        events: { input: onChange ? (e) => onChange(e.target.value, e) : undefined },
      });
      if (defaultValue !== undefined) inputEl.value = defaultValue;

      const children = [];
      if (label) { children.push(createElement({ tag: 'label', style: { display: 'block', marginBottom: t.spacing.xs, fontSize: t.fontSize.sm, fontWeight: '500', color: t.colors.text }, attrs: { for: id }, children: [label] })); }
      children.push(inputEl);
      if (errorMessage || helperText) { children.push(createElement({ tag: 'span', style: { display: 'block', marginTop: t.spacing.xs, fontSize: t.fontSize.xs, color: errorMessage ? t.colors.danger : t.colors.textMuted }, children: [errorMessage || helperText || ''] })); }

      return createElement({ tag: 'div', className: mergeClasses('zylix-input', className), children });
    }

    function Select(props) {
      const { options, size = 'md', placeholder, value, defaultValue, disabled = false, error, label, onChange, className, id = createId() } = props;
      const t = theme.get();
      const sizeStyles = getSizeStyles(size, 'input');
      const hasError = !!error;

      const optionElements = [];
      if (placeholder) { optionElements.push(createElement({ tag: 'option', attrs: { value: '', disabled: true, selected: !value && !defaultValue }, children: [placeholder] })); }
      for (const opt of options) { optionElements.push(createElement({ tag: 'option', attrs: { value: opt.value, disabled: opt.disabled, selected: value === opt.value || defaultValue === opt.value }, children: [opt.label] })); }

      const selectEl = createElement({
        tag: 'select', style: { width: '100%', border: `1px solid ${hasError ? t.colors.danger : t.colors.border}`, borderRadius: t.borderRadius.md, backgroundColor: disabled ? t.colors.surface : t.colors.background, color: t.colors.text, outline: 'none', cursor: disabled ? 'not-allowed' : 'pointer', ...sizeStyles },
        attrs: { id, disabled, 'aria-invalid': hasError }, children: optionElements, events: { change: onChange ? (e) => onChange(e.target.value, e) : undefined },
      });

      const children = [];
      if (label) { children.push(createElement({ tag: 'label', style: { display: 'block', marginBottom: t.spacing.xs, fontSize: t.fontSize.sm, fontWeight: '500', color: t.colors.text }, attrs: { for: id }, children: [label] })); }
      children.push(selectEl);
      return createElement({ tag: 'div', className: mergeClasses('zylix-select', className), children });
    }

    function Checkbox(props) {
      const { checked, defaultChecked, disabled = false, label, size = 'md', onChange, className, id = createId() } = props;
      const t = theme.get();
      const sizes = { xs: '14px', sm: '16px', md: '18px', lg: '20px', xl: '24px' };
      const inputEl = createElement({ tag: 'input', style: { width: sizes[size], height: sizes[size], margin: '0', cursor: disabled ? 'not-allowed' : 'pointer', accentColor: t.colors.primary }, attrs: { type: 'checkbox', id, checked: checked ?? defaultChecked, disabled }, events: { change: onChange ? (e) => onChange(e.target.checked, e) : undefined } });
      const children = [inputEl];
      if (label) { children.push(createElement({ tag: 'span', style: { marginLeft: t.spacing.sm, fontSize: getSizeStyles(size, 'text').fontSize, color: disabled ? t.colors.textMuted : t.colors.text }, children: [label] })); }
      return createElement({ tag: 'label', className: mergeClasses('zylix-checkbox', className), style: { display: 'inline-flex', alignItems: 'center', cursor: disabled ? 'not-allowed' : 'pointer' }, attrs: { for: id }, children });
    }

    function Radio(props) {
      const { name, value, checked = false, disabled = false, label, size = 'md', onChange, className, id = createId() } = props;
      const t = theme.get();
      const inputEl = createElement({ tag: 'input', style: { margin: '0', cursor: disabled ? 'not-allowed' : 'pointer', accentColor: t.colors.primary }, attrs: { type: 'radio', id, name, value, checked, disabled }, events: { change: onChange ? (e) => onChange(e.target.value, e) : undefined } });
      const children = [inputEl];
      if (label) { children.push(createElement({ tag: 'span', style: { marginLeft: t.spacing.sm, fontSize: getSizeStyles(size, 'text').fontSize, color: disabled ? t.colors.textMuted : t.colors.text }, children: [label] })); }
      return createElement({ tag: 'label', className: mergeClasses('zylix-radio', className), style: { display: 'inline-flex', alignItems: 'center', cursor: disabled ? 'not-allowed' : 'pointer' }, attrs: { for: id }, children });
    }

    // Data Display Components
    function Card(props) {
      const { variant = 'elevated', padding, radius = 'lg', className, children } = props;
      const t = theme.get();
      const variantStyles = { elevated: { backgroundColor: t.colors.background, boxShadow: t.shadow.md, border: 'none' }, outlined: { backgroundColor: t.colors.background, boxShadow: 'none', border: `1px solid ${t.colors.border}` }, filled: { backgroundColor: t.colors.surface, boxShadow: 'none', border: 'none' } };
      return createElement({ tag: 'div', className: mergeClasses('zylix-card', className), style: { padding: padding || t.spacing.lg, borderRadius: t.borderRadius[radius], transition: `all ${t.transition.fast}`, textAlign: 'left', width: '100%', ...variantStyles[variant] }, children });
    }

    function Avatar(props) {
      const { src, alt, name, size = 'md', shape = 'circle', className } = props;
      const t = theme.get();
      const sizes = { xs: '24px', sm: '32px', md: '40px', lg: '48px', xl: '64px' };
      const avatarSize = typeof size === 'number' ? `${size}px` : sizes[size];
      const fontSize = typeof size === 'number' ? `${size / 2.5}px` : getSizeStyles(size, 'text').fontSize;
      const getInitials = (name) => name.split(' ').map(part => part[0]).join('').toUpperCase().slice(0, 2);
      const bgColors = [t.colors.primary, t.colors.secondary, t.colors.success, t.colors.warning, t.colors.danger, t.colors.info];
      const getColorFromName = (name) => { let hash = 0; for (let i = 0; i < name.length; i++) hash = name.charCodeAt(i) + ((hash << 5) - hash); return bgColors[Math.abs(hash) % bgColors.length]; };
      const children = [];
      if (src) { children.push(createElement({ tag: 'img', style: { width: '100%', height: '100%', objectFit: 'cover' }, attrs: { src, alt: alt || name || 'Avatar' } })); }
      else if (name) { children.push(getInitials(name)); }
      return createElement({ tag: 'div', className: mergeClasses('zylix-avatar', className), style: { width: avatarSize, height: avatarSize, borderRadius: shape === 'circle' ? t.borderRadius.full : t.borderRadius.md, backgroundColor: name ? getColorFromName(name) : t.colors.secondary, color: t.colors.textInverse, display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize, fontWeight: '500', overflow: 'hidden', flexShrink: '0' }, attrs: { role: 'img', 'aria-label': alt || name || 'Avatar' }, children });
    }

    function Badge(props) {
      const { variant = 'primary', size = 'md', rounded = false, dot = false, className, children } = props;
      const t = theme.get();
      const colors = getVariantColors(variant);
      const sizes = { xs: { padding: `${t.spacing.xs} ${t.spacing.sm}`, fontSize: '10px' }, sm: { padding: `${t.spacing.xs} ${t.spacing.sm}`, fontSize: t.fontSize.xs }, md: { padding: `${t.spacing.xs} ${t.spacing.md}`, fontSize: t.fontSize.sm }, lg: { padding: `${t.spacing.sm} ${t.spacing.md}`, fontSize: t.fontSize.md }, xl: { padding: `${t.spacing.sm} ${t.spacing.lg}`, fontSize: t.fontSize.lg } };
      if (dot) { return createElement({ tag: 'span', className: mergeClasses('zylix-badge', 'zylix-badge-dot', className), style: { display: 'inline-block', width: '8px', height: '8px', borderRadius: t.borderRadius.full, backgroundColor: colors.bg } }); }
      return createElement({ tag: 'span', className: mergeClasses('zylix-badge', className), style: { display: 'inline-flex', alignItems: 'center', justifyContent: 'center', borderRadius: rounded ? t.borderRadius.full : t.borderRadius.sm, backgroundColor: colors.bg, color: colors.text, fontWeight: '500', whiteSpace: 'nowrap', ...sizes[size] }, children });
    }

    function Tag(props) {
      const { variant = 'secondary', size = 'md', removable = false, onRemove, className, children = [] } = props;
      const t = theme.get();
      const colors = getVariantColors(variant);
      const sizes = { xs: { padding: `2px ${t.spacing.sm}`, fontSize: '10px' }, sm: { padding: `${t.spacing.xs} ${t.spacing.sm}`, fontSize: t.fontSize.xs }, md: { padding: `${t.spacing.xs} ${t.spacing.md}`, fontSize: t.fontSize.sm }, lg: { padding: `${t.spacing.sm} ${t.spacing.md}`, fontSize: t.fontSize.md }, xl: { padding: `${t.spacing.sm} ${t.spacing.lg}`, fontSize: t.fontSize.lg } };
      const tagChildren = [...children];
      if (removable) {
        tagChildren.push(createElement({ tag: 'button', style: { display: 'inline-flex', alignItems: 'center', justifyContent: 'center', padding: '0', border: 'none', background: 'none', color: 'inherit', cursor: 'pointer', opacity: '0.7', marginLeft: t.spacing.xs }, attrs: { type: 'button', 'aria-label': 'Remove' }, children: ['×'], events: { click: (e) => { e.stopPropagation(); if (onRemove) onRemove(); } } }));
      }
      return createElement({ tag: 'span', className: mergeClasses('zylix-tag', className), style: { display: 'inline-flex', alignItems: 'center', borderRadius: t.borderRadius.md, backgroundColor: `${colors.bg}20`, color: colors.bg, fontWeight: '500', ...sizes[size] }, children: tagChildren });
    }

    // Feedback Components
    function Alert(props) {
      const { variant = 'info', title, closable = false, onClose, className, children } = props;
      const t = theme.get();
      const variantStyles = { info: { bg: `${t.colors.info}15`, border: t.colors.info, text: t.colors.info, icon: 'ℹ️' }, success: { bg: `${t.colors.success}15`, border: t.colors.success, text: t.colors.success, icon: '✓' }, warning: { bg: `${t.colors.warning}15`, border: t.colors.warning, text: t.colors.warning, icon: '⚠' }, danger: { bg: `${t.colors.danger}15`, border: t.colors.danger, text: t.colors.danger, icon: '✕' } };
      const styles = variantStyles[variant];
      const alertChildren = [];
      alertChildren.push(createElement({ tag: 'span', style: { marginRight: t.spacing.sm, fontSize: t.fontSize.lg }, children: [styles.icon] }));
      const contentChildren = [];
      if (title) contentChildren.push(createElement({ tag: 'div', style: { fontWeight: '600', marginBottom: children ? t.spacing.xs : undefined }, children: [title] }));
      if (children) contentChildren.push(createElement({ tag: 'div', children }));
      alertChildren.push(createElement({ tag: 'div', style: { flex: '1' }, children: contentChildren }));
      if (closable) { alertChildren.push(createElement({ tag: 'button', style: { padding: t.spacing.xs, border: 'none', background: 'none', color: styles.text, cursor: 'pointer', opacity: '0.7', fontSize: t.fontSize.lg }, attrs: { type: 'button', 'aria-label': 'Close' }, children: ['×'], events: { click: () => { if (onClose) onClose(); } } })); }
      return createElement({ tag: 'div', className: mergeClasses('zylix-alert', className), style: { display: 'flex', alignItems: 'flex-start', padding: t.spacing.md, backgroundColor: styles.bg, borderLeft: `4px solid ${styles.border}`, borderRadius: t.borderRadius.md, color: styles.text }, attrs: { role: 'alert' }, children: alertChildren });
    }

    function Progress(props) {
      const { value, max = 100, size = 'md', variant = 'primary', showLabel = false, className } = props;
      const t = theme.get();
      const colors = getVariantColors(variant);
      const percentage = Math.min(100, Math.max(0, (value / max) * 100));
      const heights = { xs: '4px', sm: '6px', md: '10px', lg: '14px', xl: '20px' };
      const bar = createElement({ tag: 'div', style: { width: `${percentage}%`, height: '100%', backgroundColor: colors.bg, borderRadius: t.borderRadius.full, transition: `width ${t.transition.normal}` }, attrs: { role: 'progressbar', 'aria-valuenow': value, 'aria-valuemin': 0, 'aria-valuemax': max } });
      const track = createElement({ tag: 'div', style: { width: '100%', height: heights[size], backgroundColor: t.colors.surface, borderRadius: t.borderRadius.full, overflow: 'hidden' }, children: [bar] });
      const children = [track];
      if (showLabel) { children.push(createElement({ tag: 'span', style: { marginLeft: t.spacing.sm, fontSize: t.fontSize.sm, color: t.colors.textSecondary, minWidth: '40px', textAlign: 'right' }, children: [`${Math.round(percentage)}%`] })); }
      return createElement({ tag: 'div', className: mergeClasses('zylix-progress', className), style: { display: 'flex', alignItems: 'center' }, children });
    }

    function Spinner(props = {}) {
      const { size = 'md', color, thickness = 3, className } = props;
      const t = theme.get();
      const sizes = { xs: '12px', sm: '16px', md: '24px', lg: '32px', xl: '48px' };
      const spinnerSize = typeof size === 'number' ? `${size}px` : sizes[size];
      if (!document.getElementById('zylix-spinner-styles')) { const styleEl = document.createElement('style'); styleEl.id = 'zylix-spinner-styles'; styleEl.textContent = `@keyframes zylix-spin { to { transform: rotate(360deg); } }`; document.head.appendChild(styleEl); }
      return createElement({ tag: 'div', className: mergeClasses('zylix-spinner', className), style: { width: spinnerSize, height: spinnerSize, border: `${thickness}px solid ${t.colors.border}`, borderTopColor: color || t.colors.primary, borderRadius: t.borderRadius.full, animation: 'zylix-spin 0.8s linear infinite' }, attrs: { role: 'status', 'aria-label': 'Loading' } });
    }

    function Skeleton(props = {}) {
      const { variant = 'text', width, height, lines = 1, className } = props;
      const t = theme.get();
      if (!document.getElementById('zylix-skeleton-styles')) { const styleEl = document.createElement('style'); styleEl.id = 'zylix-skeleton-styles'; styleEl.textContent = `@keyframes zylix-skeleton-pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }`; document.head.appendChild(styleEl); }
      const createSkeletonLine = (w, h) => {
        const getWidth = () => { if (w !== undefined) return typeof w === 'number' ? `${w}px` : w; return variant === 'circular' ? (h !== undefined ? (typeof h === 'number' ? `${h}px` : h) : '40px') : '100%'; };
        const getHeight = () => { if (h !== undefined) return typeof h === 'number' ? `${h}px` : h; if (variant === 'text') return t.fontSize.md; if (variant === 'circular') return getWidth(); return '100px'; };
        return createElement({ tag: 'div', style: { width: getWidth(), height: getHeight(), backgroundColor: t.colors.surface, borderRadius: variant === 'circular' ? t.borderRadius.full : t.borderRadius.sm, animation: 'zylix-skeleton-pulse 1.5s ease-in-out infinite' } });
      };
      if (lines === 1 || variant !== 'text') { return createElement({ tag: 'div', className: mergeClasses('zylix-skeleton', className), children: [createSkeletonLine(width, height)] }); }
      const skeletonLines = [];
      for (let i = 0; i < lines; i++) { skeletonLines.push(createSkeletonLine(i === lines - 1 ? '75%' : '100%', height)); }
      return createElement({ tag: 'div', className: mergeClasses('zylix-skeleton', className), style: { display: 'flex', flexDirection: 'column', gap: t.spacing.sm }, children: skeletonLines });
    }

    // Navigation Components
    function Tabs(props) {
      const { tabs, activeTab, defaultTab, variant = 'line', size = 'md', onChange, className } = props;
      const t = theme.get();
      let currentTab = activeTab ?? defaultTab ?? tabs[0]?.id;
      const sizeStyles = getSizeStyles(size, 'button');
      const tabButtons = tabs.map(tab => {
        const isActive = tab.id === currentTab;
        const getTabStyles = () => {
          const base = { ...sizeStyles, border: 'none', backgroundColor: 'transparent', color: isActive ? t.colors.primary : t.colors.textSecondary, cursor: tab.disabled ? 'not-allowed' : 'pointer', opacity: tab.disabled ? '0.5' : '1', transition: `all ${t.transition.fast}`, fontWeight: isActive ? '600' : '400' };
          if (variant === 'line') { base.borderBottom = isActive ? `2px solid ${t.colors.primary}` : '2px solid transparent'; base.marginBottom = '-1px'; }
          else if (variant === 'pills') { base.backgroundColor = isActive ? t.colors.primary : 'transparent'; base.color = isActive ? t.colors.textInverse : t.colors.textSecondary; base.borderRadius = t.borderRadius.full; }
          return base;
        };
        return createElement({ tag: 'button', className: 'zylix-tab-button', style: getTabStyles(), attrs: { type: 'button', role: 'tab', 'aria-selected': isActive, disabled: tab.disabled }, children: [tab.label], events: !tab.disabled ? { click: () => { currentTab = tab.id; if (onChange) onChange(tab.id); } } : undefined });
      });
      const tabList = createElement({ tag: 'div', style: { display: 'flex', gap: variant === 'pills' ? t.spacing.sm : '0', borderBottom: variant === 'line' ? `1px solid ${t.colors.border}` : undefined }, attrs: { role: 'tablist' }, children: tabButtons });
      return createElement({ tag: 'div', className: mergeClasses('zylix-tabs', className), children: [tabList] });
    }

    function Breadcrumb(props) {
      const { items, separator = '/', className } = props;
      const t = theme.get();
      const breadcrumbItems = [];
      items.forEach((item, index) => {
        const isLast = index === items.length - 1;
        if (index > 0) { breadcrumbItems.push(createElement({ tag: 'span', style: { margin: `0 ${t.spacing.sm}`, color: t.colors.textMuted }, attrs: { 'aria-hidden': 'true' }, children: [separator] })); }
        if (isLast || (!item.href && !item.onClick)) { breadcrumbItems.push(createElement({ tag: 'span', style: { color: isLast ? t.colors.text : t.colors.textSecondary, fontWeight: isLast ? '500' : undefined }, attrs: isLast ? { 'aria-current': 'page' } : undefined, children: [item.label] })); }
        else { breadcrumbItems.push(createElement({ tag: 'a', style: { color: t.colors.primary, textDecoration: 'none', cursor: 'pointer' }, attrs: item.href ? { href: item.href } : undefined, children: [item.label], events: item.onClick ? { click: item.onClick } : undefined })); }
      });
      return createElement({ tag: 'nav', className: mergeClasses('zylix-breadcrumb', className), style: { fontSize: t.fontSize.sm }, attrs: { 'aria-label': 'Breadcrumb' }, children: [createElement({ tag: 'ol', style: { display: 'flex', alignItems: 'center', listStyle: 'none', margin: '0', padding: '0' }, children: breadcrumbItems.map(item => createElement({ tag: 'li', style: { display: 'inline-flex', alignItems: 'center' }, children: [item] })) })] });
    }

    function Pagination(props) {
      const { total, page, defaultPage = 1, pageSize = 10, siblings = 1, boundaries = 1, showFirst = true, showLast = true, onChange, className } = props;
      const t = theme.get();
      let currentPage = page ?? defaultPage;
      const totalPages = Math.ceil(total / pageSize);
      const range = (start, end) => Array.from({ length: end - start + 1 }, (_, i) => start + i);
      const getPageNumbers = () => {
        const totalNumbers = siblings * 2 + 3 + boundaries * 2;
        if (totalNumbers >= totalPages) return range(1, totalPages);
        const leftSiblingIndex = Math.max(currentPage - siblings, boundaries + 1);
        const rightSiblingIndex = Math.min(currentPage + siblings, totalPages - boundaries);
        const showLeftDots = leftSiblingIndex > boundaries + 2;
        const showRightDots = rightSiblingIndex < totalPages - boundaries - 1;
        if (!showLeftDots && showRightDots) { const leftItemCount = 3 + 2 * siblings + boundaries; return [...range(1, leftItemCount), '...', ...range(totalPages - boundaries + 1, totalPages)]; }
        if (showLeftDots && !showRightDots) { const rightItemCount = 3 + 2 * siblings + boundaries; return [...range(1, boundaries), '...', ...range(totalPages - rightItemCount + 1, totalPages)]; }
        return [...range(1, boundaries), '...', ...range(leftSiblingIndex, rightSiblingIndex), '...', ...range(totalPages - boundaries + 1, totalPages)];
      };
      const createButton = (content, pageNum, disabled = false) => {
        const isActive = pageNum === currentPage;
        return createElement({ tag: 'button', style: { minWidth: '32px', height: '32px', padding: `0 ${t.spacing.sm}`, border: `1px solid ${isActive ? t.colors.primary : t.colors.border}`, borderRadius: t.borderRadius.sm, backgroundColor: isActive ? t.colors.primary : t.colors.background, color: isActive ? t.colors.textInverse : t.colors.text, cursor: disabled || isActive ? 'default' : 'pointer', opacity: disabled ? '0.5' : '1', fontSize: t.fontSize.sm }, attrs: { type: 'button', disabled, 'aria-current': isActive ? 'page' : undefined }, children: [String(content)], events: !disabled && !isActive && pageNum ? { click: () => { currentPage = pageNum; if (onChange) onChange(pageNum); } } : undefined });
      };
      const buttons = [];
      if (showFirst) buttons.push(createButton('«', 1, currentPage === 1));
      buttons.push(createButton('‹', currentPage - 1, currentPage === 1));
      for (const pageNum of getPageNumbers()) { if (pageNum === '...') buttons.push(createElement({ tag: 'span', style: { padding: `0 ${t.spacing.sm}`, color: t.colors.textMuted }, children: ['...'] })); else buttons.push(createButton(pageNum, pageNum)); }
      buttons.push(createButton('›', currentPage + 1, currentPage === totalPages));
      if (showLast) buttons.push(createButton('»', totalPages, currentPage === totalPages));
      return createElement({ tag: 'nav', className: mergeClasses('zylix-pagination', className), style: { display: 'flex', alignItems: 'center', gap: t.spacing.xs }, attrs: { 'aria-label': 'Pagination' }, children: buttons });
    }

    function Menu(props) {
      const { items, className } = props;
      const t = theme.get();
      const menuItems = items.map(item => createElement({ tag: 'button', style: { display: 'flex', alignItems: 'center', gap: t.spacing.sm, width: '100%', padding: `${t.spacing.sm} ${t.spacing.md}`, border: 'none', backgroundColor: 'transparent', color: item.danger ? t.colors.danger : t.colors.text, cursor: item.disabled ? 'not-allowed' : 'pointer', opacity: item.disabled ? '0.5' : '1', fontSize: t.fontSize.sm, textAlign: 'left' }, attrs: { type: 'button', disabled: item.disabled, role: 'menuitem' }, children: [item.label], events: !item.disabled && item.onClick ? { click: item.onClick } : undefined }));
      return createElement({ tag: 'div', className: mergeClasses('zylix-menu', className), style: { minWidth: '160px', padding: t.spacing.xs, backgroundColor: t.colors.background, border: `1px solid ${t.colors.border}`, borderRadius: t.borderRadius.md, boxShadow: t.shadow.lg }, attrs: { role: 'menu' }, children: menuItems });
    }

    // ==========================================================================
    // TESTS
    // ==========================================================================

    // Theme Tests
    describe('Theme System', () => {
      test('theme.get() returns current theme', () => {
        const t = theme.get();
        expect(t).toHaveProperty('colors');
        expect(t).toHaveProperty('spacing');
        expect(t).toHaveProperty('borderRadius');
        expect(t).toHaveProperty('fontSize');
        expect(t).toHaveProperty('shadow');
        expect(t).toHaveProperty('transition');
      });

      test('theme.set() updates theme with object', () => {
        const originalPrimary = theme.get().colors.primary;
        theme.set({ colors: { primary: '#ff0000' } });
        expect(theme.get().colors.primary).toBe('#ff0000');
        theme.set({ colors: { primary: originalPrimary } });
      });

      test('theme.set() updates theme with function', () => {
        const originalPrimary = theme.get().colors.primary;
        theme.set(t => ({ colors: { primary: '#00ff00' } }));
        expect(theme.get().colors.primary).toBe('#00ff00');
        theme.set({ colors: { primary: originalPrimary } });
      });

      test('theme.reset() restores default theme', () => {
        theme.set({ colors: { primary: '#ff0000' } });
        theme.reset();
        expect(theme.get().colors.primary).toBe(defaultTheme.colors.primary);
      });

      test('theme.subscribe() notifies on changes', () => {
        let called = false;
        const unsubscribe = theme.subscribe(() => { called = true; });
        theme.set({ colors: { primary: '#ff0000' } });
        expect(called).toBeTruthy();
        unsubscribe();
        theme.reset();
      });
    });

    // Utility Tests
    describe('Utilities', () => {
      test('createId() generates unique IDs', () => {
        const id1 = createId();
        const id2 = createId();
        expect(id1).not.toBe(id2);
        expect(id1).toContain('zylix-');
      });

      test('mergeClasses() combines class names', () => {
        expect(mergeClasses('a', 'b', 'c')).toBe('a b c');
        expect(mergeClasses('a', null, 'b', undefined, 'c')).toBe('a b c');
        expect(mergeClasses('a', false, 'b')).toBe('a b');
      });

      test('createStyleString() generates CSS string', () => {
        const style = createStyleString({ color: 'red', backgroundColor: 'blue' });
        expect(style).toContain('color: red');
        expect(style).toContain('background-color: blue');
      });

      test('getVariantColors() returns correct colors', () => {
        const colors = getVariantColors('primary');
        expect(colors).toHaveProperty('bg');
        expect(colors).toHaveProperty('text');
        expect(colors).toHaveProperty('border');
        expect(colors).toHaveProperty('hover');
      });

      test('getSizeStyles() returns correct sizes', () => {
        const buttonStyles = getSizeStyles('md', 'button');
        expect(buttonStyles).toHaveProperty('padding');
        expect(buttonStyles).toHaveProperty('fontSize');
        expect(buttonStyles).toHaveProperty('height');
      });
    });

    // createElement Tests
    describe('createElement', () => {
      test('creates element with correct tag', () => {
        const el = createElement({ tag: 'span' });
        expect(el.tagName).toBe('SPAN');
      });

      test('applies className', () => {
        const el = createElement({ className: 'test-class' });
        expect(el.className).toContain('test-class');
        expect(el.className).toContain('zylix-component');
      });

      test('applies styles', () => {
        const el = createElement({ style: { color: 'red' } });
        expect(el.style.color).toBe('red');
      });

      test('applies attributes', () => {
        const el = createElement({ attrs: { id: 'test-id', disabled: true } });
        expect(el.id).toBe('test-id');
        expect(el.hasAttribute('disabled')).toBeTruthy();
      });

      test('appends children', () => {
        const el = createElement({ children: ['Hello', createElement({ tag: 'span', children: ['World'] })] });
        expect(el.textContent).toBe('HelloWorld');
        expect(el.children.length).toBe(1);
      });

      test('attaches event listeners', () => {
        let clicked = false;
        const el = createElement({ tag: 'button', events: { click: () => { clicked = true; } } });
        el.click();
        expect(clicked).toBeTruthy();
      });

      test('calls ref callback', () => {
        let refEl = null;
        const el = createElement({ ref: (e) => { refEl = e; } });
        expect(refEl).toBe(el);
      });
    });

    // Layout Component Tests
    describe('Container', () => {
      test('creates container element', () => {
        const el = Container({ children: ['Content'] });
        expect(el.tagName).toBe('DIV');
        expect(el.className).toContain('zylix-container');
      });

      test('applies maxWidth', () => {
        const el = Container({ maxWidth: 'sm' });
        expect(el.style.maxWidth).toBe(theme.get().breakpoints.sm);
      });

      test('centers by default', () => {
        const el = Container({});
        expect(el.style.margin).toBe('0px auto');
      });
    });

    describe('Flex', () => {
      test('creates flex container', () => {
        const el = Flex({ children: ['Item'] });
        expect(el.style.display).toBe('flex');
      });

      test('applies direction', () => {
        const el = Flex({ direction: 'column' });
        expect(el.style.flexDirection).toBe('column');
      });

      test('applies justify', () => {
        const el = Flex({ justify: 'between' });
        expect(el.style.justifyContent).toBe('space-between');
      });

      test('applies align', () => {
        const el = Flex({ align: 'center' });
        expect(el.style.alignItems).toBe('center');
      });
    });

    describe('Grid', () => {
      test('creates grid container', () => {
        const el = Grid({ children: ['Item'] });
        expect(el.style.display).toBe('grid');
      });

      test('applies columns', () => {
        const el = Grid({ columns: 3 });
        expect(el.style.gridTemplateColumns).toBe('repeat(3, 1fr)');
      });

      test('applies custom column template', () => {
        const el = Grid({ columns: '1fr 2fr 1fr' });
        expect(el.style.gridTemplateColumns).toBe('1fr 2fr 1fr');
      });
    });

    describe('Stack', () => {
      test('creates vertical stack by default', () => {
        const el = Stack({ children: ['Item'] });
        expect(el.style.flexDirection).toBe('column');
      });

      test('creates horizontal stack', () => {
        const el = Stack({ direction: 'horizontal', children: ['Item'] });
        expect(el.style.flexDirection).toBe('row');
      });
    });

    describe('Divider', () => {
      test('creates horizontal divider', () => {
        const el = Divider();
        expect(el.tagName).toBe('HR');
        expect(el.style.width).toBe('100%');
      });

      test('creates vertical divider', () => {
        const el = Divider({ orientation: 'vertical' });
        expect(el.style.height).toBe('100%');
      });

      test('has separator role', () => {
        const el = Divider();
        expect(el.getAttribute('role')).toBe('separator');
      });
    });

    // Form Component Tests
    describe('Button', () => {
      test('creates button element', () => {
        const el = Button({ children: ['Click'] });
        expect(el.tagName).toBe('BUTTON');
        expect(el.textContent).toBe('Click');
      });

      test('applies variant styles', () => {
        const el = Button({ variant: 'primary' });
        expect(el.style.backgroundColor).toBe(hexToRgb(theme.get().colors.primary));
      });

      test('handles disabled state', () => {
        const el = Button({ disabled: true });
        expect(el.disabled).toBeTruthy();
        expect(el.style.opacity).toBe('0.5');
      });

      test('handles loading state', () => {
        const el = Button({ loading: true });
        expect(el.disabled).toBeTruthy();
        expect(el.hasAttribute('aria-busy')).toBeTruthy();
      });

      test('calls onClick handler', () => {
        let clicked = false;
        const el = Button({ onClick: () => { clicked = true; } });
        el.click();
        expect(clicked).toBeTruthy();
      });

      test('applies fullWidth', () => {
        const el = Button({ fullWidth: true });
        expect(el.style.width).toBe('100%');
      });
    });

    describe('Input', () => {
      test('creates input wrapper with input element', () => {
        const el = Input({ placeholder: 'Enter text' });
        const input = el.querySelector('input');
        expect(input).not.toBeNull();
        expect(input.placeholder).toBe('Enter text');
      });

      test('applies label', () => {
        const el = Input({ label: 'Email' });
        const label = el.querySelector('label');
        expect(label).not.toBeNull();
        expect(label.textContent).toBe('Email');
      });

      test('shows error message', () => {
        const el = Input({ error: 'Required field' });
        expect(el.textContent).toContain('Required field');
      });

      test('shows helper text', () => {
        const el = Input({ helperText: 'Enter your email' });
        expect(el.textContent).toContain('Enter your email');
      });

      test('handles disabled state', () => {
        const el = Input({ disabled: true });
        const input = el.querySelector('input');
        expect(input.disabled).toBeTruthy();
      });

      test('sets aria-invalid on error', () => {
        const el = Input({ error: true });
        const input = el.querySelector('input');
        expect(input.hasAttribute('aria-invalid')).toBeTruthy();
      });
    });

    describe('Select', () => {
      test('creates select element with options', () => {
        const el = Select({ options: [{ value: 'a', label: 'A' }, { value: 'b', label: 'B' }] });
        const select = el.querySelector('select');
        expect(select).not.toBeNull();
        expect(select.options.length).toBe(2);
      });

      test('applies placeholder', () => {
        const el = Select({ placeholder: 'Select...', options: [{ value: 'a', label: 'A' }] });
        const select = el.querySelector('select');
        expect(select.options[0].text).toBe('Select...');
        expect(select.options[0].disabled).toBeTruthy();
      });

      test('applies label', () => {
        const el = Select({ label: 'Country', options: [] });
        const label = el.querySelector('label');
        expect(label.textContent).toBe('Country');
      });
    });

    describe('Checkbox', () => {
      test('creates checkbox input', () => {
        const el = Checkbox({ label: 'Agree' });
        const input = el.querySelector('input');
        expect(input.type).toBe('checkbox');
      });

      test('applies label', () => {
        const el = Checkbox({ label: 'Terms' });
        expect(el.textContent).toContain('Terms');
      });

      test('handles defaultChecked', () => {
        const el = Checkbox({ defaultChecked: true });
        const input = el.querySelector('input');
        expect(input.checked).toBeTruthy();
      });

      test('handles disabled state', () => {
        const el = Checkbox({ disabled: true });
        const input = el.querySelector('input');
        expect(input.disabled).toBeTruthy();
      });
    });

    describe('Radio', () => {
      test('creates radio input', () => {
        const el = Radio({ name: 'test', value: 'a', label: 'Option A' });
        const input = el.querySelector('input');
        expect(input.type).toBe('radio');
        expect(input.name).toBe('test');
        expect(input.value).toBe('a');
      });

      test('applies label', () => {
        const el = Radio({ name: 'test', value: 'a', label: 'Option A' });
        expect(el.textContent).toContain('Option A');
      });
    });

    // Data Display Tests
    describe('Card', () => {
      test('creates card element', () => {
        const el = Card({ children: ['Content'] });
        expect(el.tagName).toBe('DIV');
        expect(el.className).toContain('zylix-card');
      });

      test('applies elevated variant', () => {
        const el = Card({ variant: 'elevated' });
        expect(el.style.boxShadow).toBeTruthy();
      });

      test('applies outlined variant', () => {
        const el = Card({ variant: 'outlined' });
        expect(el.style.border).toContain('solid');
      });

      test('applies filled variant', () => {
        const el = Card({ variant: 'filled' });
        expect(el.style.backgroundColor).toBe(hexToRgb(theme.get().colors.surface));
      });
    });

    describe('Avatar', () => {
      test('creates avatar element', () => {
        const el = Avatar({ name: 'John Doe' });
        expect(el.className).toContain('zylix-avatar');
      });

      test('shows initials from name', () => {
        const el = Avatar({ name: 'John Doe' });
        expect(el.textContent).toBe('JD');
      });

      test('applies size', () => {
        const el = Avatar({ name: 'JD', size: 'lg' });
        expect(el.style.width).toBe('48px');
      });

      test('applies circle shape by default', () => {
        const el = Avatar({ name: 'JD' });
        expect(el.style.borderRadius).toBe(theme.get().borderRadius.full);
      });

      test('applies square shape', () => {
        const el = Avatar({ name: 'JD', shape: 'square' });
        expect(el.style.borderRadius).toBe(theme.get().borderRadius.md);
      });

      test('has img role', () => {
        const el = Avatar({ name: 'John' });
        expect(el.getAttribute('role')).toBe('img');
      });
    });

    describe('Badge', () => {
      test('creates badge element', () => {
        const el = Badge({ children: ['New'] });
        expect(el.tagName).toBe('SPAN');
        expect(el.textContent).toBe('New');
      });

      test('applies variant colors', () => {
        const el = Badge({ variant: 'success' });
        expect(el.style.backgroundColor).toBe(hexToRgb(theme.get().colors.success));
      });

      test('creates dot badge', () => {
        const el = Badge({ dot: true });
        expect(el.style.width).toBe('8px');
        expect(el.style.height).toBe('8px');
      });

      test('applies rounded style', () => {
        const el = Badge({ rounded: true });
        expect(el.style.borderRadius).toBe(theme.get().borderRadius.full);
      });
    });

    describe('Tag', () => {
      test('creates tag element', () => {
        const el = Tag({ children: ['React'] });
        expect(el.tagName).toBe('SPAN');
        expect(el.textContent).toBe('React');
      });

      test('applies variant color with opacity', () => {
        const el = Tag({ variant: 'primary' });
        // Browser converts hex+opacity (e.g., #3b82f620) to rgba format
        expect(el.style.backgroundColor).toContain('rgba');
      });

      test('adds remove button when removable', () => {
        const el = Tag({ removable: true, children: ['Tag'] });
        const removeBtn = el.querySelector('button');
        expect(removeBtn).not.toBeNull();
      });

      test('calls onRemove when remove button clicked', () => {
        let removed = false;
        const el = Tag({ removable: true, onRemove: () => { removed = true; }, children: ['Tag'] });
        const removeBtn = el.querySelector('button');
        removeBtn.click();
        expect(removed).toBeTruthy();
      });
    });

    // Feedback Component Tests
    describe('Alert', () => {
      test('creates alert element', () => {
        const el = Alert({ children: ['Message'] });
        expect(el.getAttribute('role')).toBe('alert');
      });

      test('applies variant styles', () => {
        const el = Alert({ variant: 'success' });
        expect(el.style.color).toBe(hexToRgb(theme.get().colors.success));
      });

      test('shows title', () => {
        const el = Alert({ title: 'Success', children: ['Done'] });
        expect(el.textContent).toContain('Success');
      });

      test('shows close button when closable', () => {
        const el = Alert({ closable: true });
        const closeBtn = el.querySelector('button');
        expect(closeBtn).not.toBeNull();
      });

      test('calls onClose when close button clicked', () => {
        let closed = false;
        const el = Alert({ closable: true, onClose: () => { closed = true; } });
        const closeBtn = el.querySelector('button');
        closeBtn.click();
        expect(closed).toBeTruthy();
      });
    });

    describe('Progress', () => {
      test('creates progress element', () => {
        const el = Progress({ value: 50 });
        const bar = el.querySelector('[role="progressbar"]');
        expect(bar).not.toBeNull();
      });

      test('applies correct width', () => {
        const el = Progress({ value: 75, max: 100 });
        const bar = el.querySelector('[role="progressbar"]');
        expect(bar.style.width).toBe('75%');
      });

      test('shows label when showLabel is true', () => {
        const el = Progress({ value: 50, showLabel: true });
        expect(el.textContent).toContain('50%');
      });

      test('sets aria attributes', () => {
        const el = Progress({ value: 30, max: 100 });
        const bar = el.querySelector('[role="progressbar"]');
        expect(bar.getAttribute('aria-valuenow')).toBe('30');
        expect(bar.getAttribute('aria-valuemin')).toBe('0');
        expect(bar.getAttribute('aria-valuemax')).toBe('100');
      });
    });

    describe('Spinner', () => {
      test('creates spinner element', () => {
        const el = Spinner();
        expect(el.getAttribute('role')).toBe('status');
      });

      test('applies size', () => {
        const el = Spinner({ size: 'lg' });
        expect(el.style.width).toBe('32px');
      });

      test('applies custom color', () => {
        const el = Spinner({ color: '#ff0000' });
        expect(el.style.borderTopColor).toBe('rgb(255, 0, 0)');
      });

      test('has loading aria-label', () => {
        const el = Spinner();
        expect(el.getAttribute('aria-label')).toBe('Loading');
      });
    });

    describe('Skeleton', () => {
      test('creates skeleton element', () => {
        const el = Skeleton();
        expect(el.className).toContain('zylix-skeleton');
      });

      test('creates circular skeleton', () => {
        const el = Skeleton({ variant: 'circular', width: 48, height: 48 });
        const inner = el.querySelector('div');
        expect(inner.style.borderRadius).toBe(theme.get().borderRadius.full);
      });

      test('creates multiple lines', () => {
        const el = Skeleton({ lines: 3 });
        expect(el.children.length).toBe(3);
      });

      test('last line is shorter', () => {
        const el = Skeleton({ lines: 3 });
        const lastLine = el.children[2];
        expect(lastLine.style.width).toBe('75%');
      });
    });

    // Navigation Component Tests
    describe('Tabs', () => {
      test('creates tabs element', () => {
        const el = Tabs({ tabs: [{ id: 'a', label: 'Tab A' }, { id: 'b', label: 'Tab B' }] });
        expect(el.className).toContain('zylix-tabs');
      });

      test('creates tab buttons', () => {
        const el = Tabs({ tabs: [{ id: 'a', label: 'Tab A' }, { id: 'b', label: 'Tab B' }] });
        const buttons = el.querySelectorAll('[role="tab"]');
        expect(buttons.length).toBe(2);
      });

      test('sets aria-selected on active tab', () => {
        const el = Tabs({ tabs: [{ id: 'a', label: 'Tab A' }, { id: 'b', label: 'Tab B' }], defaultTab: 'a' });
        const buttons = el.querySelectorAll('[role="tab"]');
        expect(buttons[0].hasAttribute('aria-selected')).toBeTruthy();
      });

      test('disables disabled tabs', () => {
        const el = Tabs({ tabs: [{ id: 'a', label: 'Tab A' }, { id: 'b', label: 'Tab B', disabled: true }] });
        const buttons = el.querySelectorAll('[role="tab"]');
        expect(buttons[1].disabled).toBeTruthy();
      });
    });

    describe('Breadcrumb', () => {
      test('creates breadcrumb element', () => {
        const el = Breadcrumb({ items: [{ label: 'Home' }, { label: 'Page' }] });
        expect(el.getAttribute('aria-label')).toBe('Breadcrumb');
      });

      test('shows separators between items', () => {
        const el = Breadcrumb({ items: [{ label: 'Home' }, { label: 'Products' }, { label: 'Item' }] });
        expect(el.textContent).toContain('/');
      });

      test('last item has aria-current', () => {
        const el = Breadcrumb({ items: [{ label: 'Home' }, { label: 'Current' }] });
        const items = el.querySelectorAll('[aria-current="page"]');
        expect(items.length).toBe(1);
      });

      test('clickable items are links', () => {
        let clicked = false;
        const el = Breadcrumb({ items: [{ label: 'Home', onClick: () => { clicked = true; } }, { label: 'Current' }] });
        const link = el.querySelector('a');
        expect(link).not.toBeNull();
      });
    });

    describe('Pagination', () => {
      test('creates pagination element', () => {
        const el = Pagination({ total: 100, pageSize: 10 });
        expect(el.getAttribute('aria-label')).toBe('Pagination');
      });

      test('shows correct number of page buttons', () => {
        const el = Pagination({ total: 30, pageSize: 10 });
        const pageButtons = el.querySelectorAll('button:not([disabled])');
        expect(pageButtons.length).toBeGreaterThan(0);
      });

      test('disables previous button on first page', () => {
        const el = Pagination({ total: 100, defaultPage: 1 });
        const buttons = el.querySelectorAll('button');
        expect(buttons[1].disabled).toBeTruthy(); // Previous button
      });

      test('disables next button on last page', () => {
        const el = Pagination({ total: 100, pageSize: 10, defaultPage: 10 });
        const buttons = el.querySelectorAll('button');
        const nextBtn = buttons[buttons.length - 2];
        expect(nextBtn.disabled).toBeTruthy();
      });

      test('calls onChange when page clicked', () => {
        let newPage = 0;
        const el = Pagination({ total: 100, pageSize: 10, onChange: (p) => { newPage = p; } });
        const pageButtons = Array.from(el.querySelectorAll('button')).filter(btn => !btn.disabled && btn.textContent.match(/^\d+$/));
        if (pageButtons[1]) {
          pageButtons[1].click();
          expect(newPage).toBeGreaterThan(0);
        }
      });
    });

    describe('Menu', () => {
      test('creates menu element', () => {
        const el = Menu({ items: [{ label: 'Item 1' }, { label: 'Item 2' }] });
        expect(el.getAttribute('role')).toBe('menu');
      });

      test('creates menu items', () => {
        const el = Menu({ items: [{ label: 'Item 1' }, { label: 'Item 2' }] });
        const items = el.querySelectorAll('[role="menuitem"]');
        expect(items.length).toBe(2);
      });

      test('disables disabled items', () => {
        const el = Menu({ items: [{ label: 'Item 1' }, { label: 'Item 2', disabled: true }] });
        const items = el.querySelectorAll('[role="menuitem"]');
        expect(items[1].disabled).toBeTruthy();
      });

      test('applies danger style', () => {
        const el = Menu({ items: [{ label: 'Delete', danger: true }] });
        const item = el.querySelector('[role="menuitem"]');
        expect(item.style.color).toBe(hexToRgb(theme.get().colors.danger));
      });
    });

    // Render Results
    function renderResults() {
      const summaryEl = document.getElementById('summary');
      const resultsEl = document.getElementById('results');

      const total = passed + failed;
      summaryEl.textContent = `${passed}/${total} tests passed`;
      summaryEl.className = `summary ${failed === 0 ? 'pass' : 'fail'}`;

      for (const [groupName, group] of Object.entries(results)) {
        const groupEl = document.createElement('div');
        groupEl.className = 'test-group';

        const headerEl = document.createElement('div');
        headerEl.className = 'test-group-header';
        headerEl.innerHTML = `
          <span>${groupName}</span>
          <span style="color: ${group.failed > 0 ? '#dc2626' : '#059669'}">${group.passed}/${group.tests.length}</span>
        `;

        const bodyEl = document.createElement('div');
        bodyEl.className = 'test-group-body';

        for (const test of group.tests) {
          const testEl = document.createElement('div');
          testEl.className = `test-item ${test.passed ? 'pass' : 'fail'}`;
          testEl.innerHTML = `
            <span class="test-icon">${test.passed ? '✓' : '✕'}</span>
            <span class="test-name">${test.name}</span>
            ${test.error ? `<div class="test-error">${test.error}</div>` : ''}
          `;
          bodyEl.appendChild(testEl);
        }

        headerEl.onclick = () => {
          bodyEl.classList.toggle('hidden');
        };

        groupEl.appendChild(headerEl);
        groupEl.appendChild(bodyEl);
        resultsEl.appendChild(groupEl);
      }
    }

    renderResults();
    console.log(`Tests completed: ${passed}/${passed + failed} passed`);
  </script>
</body>
</html>
