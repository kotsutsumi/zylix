---
title: "Virtual DOM"
weight: 4
---

# Virtual DOM

The VDOM module (`vdom.zig`) provides a Virtual DOM implementation for efficient UI reconciliation, including key-based diffing for optimal performance.

## Overview

The Virtual DOM represents UI structure as a tree that can be efficiently diffed against a previous version to compute minimal updates:

```
┌─────────────────────────────────────────────┐
│                 VTree                        │
│  ┌─────────────┐                            │
│  │   VNode     │ ◄── Root node              │
│  │  (element)  │                            │
│  └──────┬──────┘                            │
│         │                                    │
│    ┌────┴────┐                              │
│    ▼         ▼                              │
│ ┌──────┐ ┌──────┐                           │
│ │VNode │ │VNode │ ◄── Children              │
│ │(text)│ │(elem)│                           │
│ └──────┘ └──────┘                           │
└─────────────────────────────────────────────┘
```

## Constants

```zig
/// Maximum children per VNode
pub const MAX_VNODE_CHILDREN: usize = 64;

/// Maximum props per VNode
pub const MAX_VNODE_PROPS: usize = 16;

/// Maximum tag name length
pub const MAX_TAG_LEN: usize = 32;

/// Maximum prop key length
pub const MAX_PROP_KEY_LEN: usize = 32;

/// Maximum prop value length
pub const MAX_PROP_VALUE_LEN: usize = 256;

/// Maximum key length for keyed children
pub const MAX_KEY_LEN: usize = 64;

/// Maximum patches per diff
pub const MAX_PATCHES: usize = 1024;
```

## Types

### VNode

Represents a single node in the virtual DOM tree.

```zig
pub const VNode = struct {
    /// Node type (element, text, etc.)
    node_type: NodeType,

    /// Unique identifier for this node
    dom_id: u32,

    /// Element tag name (for element nodes)
    tag: [MAX_TAG_LEN]u8,
    tag_len: usize,

    /// Text content (for text nodes)
    text: [MAX_PROP_VALUE_LEN]u8,
    text_len: usize,

    /// Key for reconciliation (optional)
    key: [MAX_KEY_LEN]u8,
    key_len: usize,

    /// Props (attributes)
    props: [MAX_VNODE_PROPS]Prop,
    prop_count: usize,

    /// Children indices (into VTree.nodes array)
    children: [MAX_VNODE_CHILDREN]u32,
    child_count: usize,

    /// Create an element node
    pub fn element(tag: []const u8) VNode;

    /// Create a text node
    pub fn text(content: []const u8) VNode;

    /// Set the key for reconciliation
    pub fn setKey(self: *VNode, k: []const u8) void;

    /// Add a prop
    pub fn addProp(self: *VNode, k: []const u8, v: []const u8) void;

    /// Get a prop value by key
    pub fn getProp(self: *const VNode, k: []const u8) ?[]const u8;

    /// Get tag as slice
    pub fn getTag(self: *const VNode) []const u8;

    /// Get text content as slice
    pub fn getText(self: *const VNode) []const u8;

    /// Get key as slice
    pub fn getKey(self: *const VNode) []const u8;
};
```

### NodeType

```zig
pub const NodeType = enum(u8) {
    element,
    text,
    component,
    fragment,
};
```

### Prop

Represents a node property (attribute).

```zig
pub const Prop = struct {
    key: [MAX_PROP_KEY_LEN]u8,
    key_len: usize,
    value: [MAX_PROP_VALUE_LEN]u8,
    value_len: usize,

    /// Get key as slice
    pub fn getKey(self: *const Prop) []const u8;

    /// Get value as slice
    pub fn getValue(self: *const Prop) []const u8;
};
```

### VTree

Container for the virtual DOM tree.

```zig
pub const VTree = struct {
    /// All nodes in the tree (flat array)
    nodes: [MAX_PATCHES]VNode,
    node_count: usize,

    /// Root node index
    root: u32,

    /// Version for change tracking
    version: u64,

    /// Initialize empty tree
    pub fn init() VTree;

    /// Add a node to the tree
    pub fn addNode(self: *VTree, node: VNode) !u32;

    /// Get node by index
    pub fn getNode(self: *const VTree, index: u32) ?*const VNode;

    /// Get mutable node by index
    pub fn getNodeMut(self: *VTree, index: u32) ?*VNode;

    /// Add child to a parent node
    pub fn addChild(self: *VTree, parent_idx: u32, child_idx: u32) !void;

    /// Bump version
    pub fn bumpVersion(self: *VTree) void;
};
```

## Diffing

### Differ

Computes patches between two virtual DOM trees.

```zig
pub const Differ = struct {
    /// Patches generated by diff
    patches: [MAX_PATCHES]Patch,
    patch_count: usize,

    /// Initialize differ
    pub fn init() Differ;

    /// Compute diff between two trees
    pub fn diff(
        self: *Differ,
        old_tree: *const VTree,
        new_tree: *const VTree
    ) void;

    /// Get patches as slice
    pub fn getPatches(self: *const Differ) []const Patch;
};
```

### Patch

Represents a single DOM operation.

```zig
pub const Patch = struct {
    /// Type of patch operation
    op: PatchOp,

    /// Target DOM ID
    dom_id: u32,

    /// Additional data depending on op type
    data: PatchData,
};

pub const PatchOp = enum(u8) {
    none,
    replace,        // Replace node
    update_text,    // Update text content
    update_props,   // Update properties
    insert_child,   // Insert new child
    remove_child,   // Remove child
    move_child,     // Move child to new position
    remove_node,    // Remove node entirely
};

pub const PatchData = union {
    none: void,
    node_index: u32,
    text: [MAX_PROP_VALUE_LEN]u8,
    props: [MAX_VNODE_PROPS]Prop,
    child: ChildPatch,
};

pub const ChildPatch = struct {
    child_dom_id: u32,
    position: u32,
};
```

## Key-Based Diffing

The VDOM supports key-based reconciliation for efficient list updates. When children have keys, the differ uses an O(n) matching algorithm:

### How It Works

1. **Key Detection**: The differ checks if any children have keys
2. **Key Map Building**: Creates a hash map of old children by key
3. **Matching**: Matches new children to old by key
4. **Patch Generation**: Generates minimal patches for moves, additions, and removals

### Benefits

- **Preserves State**: Keyed elements maintain their state across re-renders
- **Efficient Updates**: Only changed elements are updated
- **Optimal Ordering**: Minimizes DOM operations for list reordering

### Usage

```zig
// Create keyed children
var item1 = VNode.element("li");
item1.setKey("item-1");
item1.addProp("class", "list-item");

var item2 = VNode.element("li");
item2.setKey("item-2");
item2.addProp("class", "list-item");

// Add to tree
const idx1 = try tree.addNode(item1);
const idx2 = try tree.addNode(item2);
try tree.addChild(parent_idx, idx1);
try tree.addChild(parent_idx, idx2);
```

### Key Hash Function

Keys are hashed using djb2 for O(1) lookup:

```zig
fn hashKey(key: []const u8) u32 {
    var hash: u32 = 5381;
    for (key) |c| {
        hash = ((hash << 5) +% hash) +% c;
    }
    return hash;
}
```

## Examples

### Creating a Simple Tree

```zig
const vdom = @import("vdom.zig");

// Create tree
var tree = vdom.VTree.init();

// Create root element
var root = vdom.VNode.element("div");
root.addProp("id", "app");
root.addProp("class", "container");

// Add root to tree
const root_idx = try tree.addNode(root);
tree.root = root_idx;

// Create child text
var text = vdom.VNode.text("Hello, World!");
const text_idx = try tree.addNode(text);

// Add text as child of root
try tree.addChild(root_idx, text_idx);
```

### Diffing Trees

```zig
// Create old tree
var old_tree = vdom.VTree.init();
var old_root = vdom.VNode.element("div");
var old_text = vdom.VNode.text("Hello");
const old_root_idx = try old_tree.addNode(old_root);
const old_text_idx = try old_tree.addNode(old_text);
old_tree.root = old_root_idx;
try old_tree.addChild(old_root_idx, old_text_idx);

// Create new tree with updated text
var new_tree = vdom.VTree.init();
var new_root = vdom.VNode.element("div");
var new_text = vdom.VNode.text("Hello, World!");
const new_root_idx = try new_tree.addNode(new_root);
const new_text_idx = try new_tree.addNode(new_text);
new_tree.root = new_root_idx;
try new_tree.addChild(new_root_idx, new_text_idx);

// Compute diff
var differ = vdom.Differ.init();
differ.diff(&old_tree, &new_tree);

// Process patches
for (differ.getPatches()) |patch| {
    switch (patch.op) {
        .update_text => {
            // Update text content
            const text_slice = patch.data.text[0..findLen(patch.data.text)];
            // Apply to DOM...
        },
        .insert_child => {
            // Insert child at position
            const child_id = patch.data.child.child_dom_id;
            const position = patch.data.child.position;
            // Apply to DOM...
        },
        // Handle other patch types...
        else => {},
    }
}
```

### Keyed List Reconciliation

```zig
// Old list: [A, B, C]
var old_tree = vdom.VTree.init();
var old_list = vdom.VNode.element("ul");
const old_list_idx = try old_tree.addNode(old_list);
old_tree.root = old_list_idx;

var item_a = vdom.VNode.element("li");
item_a.setKey("a");
var item_b = vdom.VNode.element("li");
item_b.setKey("b");
var item_c = vdom.VNode.element("li");
item_c.setKey("c");

// Add items...

// New list: [C, A, B] (reordered)
var new_tree = vdom.VTree.init();
// Items with same keys but different order...

// Diff will generate move patches instead of remove/insert
var differ = vdom.Differ.init();
differ.diff(&old_tree, &new_tree);

// Patches will contain move_child operations
for (differ.getPatches()) |patch| {
    if (patch.op == .move_child) {
        // Efficiently reorder instead of recreating
    }
}
```

## Platform Integration

### Web (WASM)

The VDOM patches can be applied to the real DOM via JavaScript:

```javascript
function applyPatch(patch, domNodes) {
    const target = domNodes.get(patch.dom_id);

    switch (patch.op) {
        case PatchOp.UPDATE_TEXT:
            target.textContent = patch.text;
            break;

        case PatchOp.INSERT_CHILD:
            const newNode = createNode(patch.child_dom_id);
            target.insertBefore(newNode, target.children[patch.position]);
            break;

        case PatchOp.REMOVE_CHILD:
            target.removeChild(domNodes.get(patch.child_dom_id));
            break;

        case PatchOp.MOVE_CHILD:
            const child = domNodes.get(patch.child_dom_id);
            target.insertBefore(child, target.children[patch.position]);
            break;
    }
}
```

### Native Platforms

For native platforms, patches translate to platform-specific UI updates:

**iOS (SwiftUI):**
```swift
// VTree changes trigger @Published property updates
// SwiftUI handles efficient re-rendering
```

**Android (Compose):**
```kotlin
// VTree changes update State objects
// Compose recomposes affected components
```
